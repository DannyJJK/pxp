#![allow(unreachable_code, unreachable_patterns)]
// This file is generated by meta/scripts/generate-ast.php.
// Do not make modifications to this file directly.

use super::Nodeable;
use crate::utils::CommaSeparated;
use pxp_span::{Span, Spanned};
use pxp_symbol::Symbol;
use pxp_syntax::backed_enum_type::BackedEnumType;
use pxp_syntax::comments::{Comment, CommentGroup};
use pxp_syntax::name::NameQualification;
use pxp_token::Token;
use pxp_type::Type;

pub type NodeId = u32;

pub type Block = Vec<Statement>;

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Statement {
    pub id: NodeId,
    pub kind: StatementKind,
    pub span: Span,
    pub comments: CommentGroup,
}

impl Nodeable for Statement {
    fn as_node(&self) -> Node {
        Node::Statement(self)
    }
}

impl Spanned for Statement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum StatementKind {
    FullOpeningTag(FullOpeningTagStatement),
    ShortOpeningTag(ShortOpeningTagStatement),
    EchoOpeningTag(EchoOpeningTagStatement),
    ClosingTag(ClosingTagStatement),
    InlineHtml(InlineHtmlStatement),
    Label(LabelStatement),
    Goto(GotoStatement),
    HaltCompiler(HaltCompilerStatement),
    Static(StaticStatement),
    DoWhile(DoWhileStatement),
    While(WhileStatement),
    For(ForStatement),
    Foreach(ForeachStatement),
    Break(BreakStatement),
    Continue(ContinueStatement),
    Constant(ConstantStatement),
    Function(FunctionStatement),
    Class(ClassStatement),
    Trait(TraitStatement),
    Interface(InterfaceStatement),
    If(IfStatement),
    Switch(SwitchStatement),
    Echo(EchoStatement),
    Expression(ExpressionStatement),
    Return(ReturnStatement),
    Namespace(NamespaceStatement),
    Use(UseStatement),
    GroupUse(GroupUseStatement),
    Comment(Comment),
    Try(TryStatement),
    UnitEnum(UnitEnumStatement),
    BackedEnum(BackedEnumStatement),
    Block(BlockStatement),
    Global(GlobalStatement),
    Declare(DeclareStatement),
    Noop(Span),
}

impl Nodeable for StatementKind {
    fn as_node(&self) -> Node {
        Node::StatementKind(self)
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Expression {
    pub id: NodeId,
    pub kind: ExpressionKind,
    pub span: Span,
    pub comments: CommentGroup,
}

impl Nodeable for Expression {
    fn as_node(&self) -> Node {
        Node::Expression(self)
    }
}

impl Spanned for Expression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ExpressionKind {
    Missing(Span),
    Eval(EvalExpression),
    Empty(EmptyExpression),
    Die(DieExpression),
    Exit(ExitExpression),
    Isset(IssetExpression),
    Unset(UnsetExpression),
    Print(PrintExpression),
    Literal(Literal),
    ArithmeticOperation(ArithmeticOperationExpression),
    AssignmentOperation(AssignmentOperationExpression),
    BitwiseOperation(BitwiseOperationExpression),
    ComparisonOperation(ComparisonOperationExpression),
    LogicalOperation(LogicalOperationExpression),
    Concat(ConcatExpression),
    Instanceof(InstanceofExpression),
    Reference(ReferenceExpression),
    Parenthesized(ParenthesizedExpression),
    ErrorSuppress(ErrorSuppressExpression),
    Identifier(Identifier),
    Variable(Variable),
    Include(IncludeExpression),
    IncludeOnce(IncludeOnceExpression),
    Require(RequireExpression),
    RequireOnce(RequireOnceExpression),
    FunctionCall(FunctionCallExpression),
    FunctionClosureCreation(FunctionClosureCreationExpression),
    MethodCall(MethodCallExpression),
    MethodClosureCreation(MethodClosureCreationExpression),
    NullsafeMethodCall(NullsafeMethodCallExpression),
    StaticMethodCall(StaticMethodCallExpression),
    StaticVariableMethodCall(StaticVariableMethodCallExpression),
    StaticMethodClosureCreation(StaticMethodClosureCreationExpression),
    StaticVariableMethodClosureCreation(StaticVariableMethodClosureCreationExpression),
    PropertyFetch(PropertyFetchExpression),
    NullsafePropertyFetch(NullsafePropertyFetchExpression),
    StaticPropertyFetch(StaticPropertyFetchExpression),
    ConstantFetch(ConstantFetchExpression),
    Static(Span),
    Self_(Span),
    Parent(Span),
    ShortArray(ShortArrayExpression),
    Array(ArrayExpression),
    List(ListExpression),
    Closure(ClosureExpression),
    ArrowFunction(ArrowFunctionExpression),
    New(NewExpression),
    InterpolatedString(InterpolatedStringExpression),
    Heredoc(HeredocExpression),
    Nowdoc(NowdocExpression),
    ShellExec(ShellExecExpression),
    AnonymousClass(AnonymousClassExpression),
    Bool(BoolExpression),
    ArrayIndex(ArrayIndexExpression),
    Null(Span),
    MagicConstant(MagicConstantExpression),
    ShortTernary(ShortTernaryExpression),
    Ternary(TernaryExpression),
    Coalesce(CoalesceExpression),
    Clone(CloneExpression),
    Match(MatchExpression),
    Throw(ThrowExpression),
    Yield(YieldExpression),
    YieldFrom(YieldFromExpression),
    Cast(CastExpression),
    Name(Name),
    Noop(Span),
}

impl Nodeable for ExpressionKind {
    fn as_node(&self) -> Node {
        Node::ExpressionKind(self)
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct InlineHtmlStatement {
    pub id: NodeId,
    pub span: Span,
    pub html: Token,
}

impl Nodeable for InlineHtmlStatement {
    fn as_node(&self) -> Node {
        Node::InlineHtmlStatement(self)
    }
}

impl Spanned for InlineHtmlStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FullOpeningTagStatement {
    pub id: NodeId,
    pub span: Span,
}

impl Nodeable for FullOpeningTagStatement {
    fn as_node(&self) -> Node {
        Node::FullOpeningTagStatement(self)
    }
}

impl Spanned for FullOpeningTagStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ShortOpeningTagStatement {
    pub id: NodeId,
    pub span: Span,
}

impl Nodeable for ShortOpeningTagStatement {
    fn as_node(&self) -> Node {
        Node::ShortOpeningTagStatement(self)
    }
}

impl Spanned for ShortOpeningTagStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct EchoOpeningTagStatement {
    pub id: NodeId,
    pub span: Span,
}

impl Nodeable for EchoOpeningTagStatement {
    fn as_node(&self) -> Node {
        Node::EchoOpeningTagStatement(self)
    }
}

impl Spanned for EchoOpeningTagStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClosingTagStatement {
    pub id: NodeId,
    pub span: Span,
}

impl Nodeable for ClosingTagStatement {
    fn as_node(&self) -> Node {
        Node::ClosingTagStatement(self)
    }
}

impl Spanned for ClosingTagStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ExpressionStatement {
    pub id: NodeId,
    pub span: Span,
    pub expression: Expression,
    pub ending: Ending,
}

impl Nodeable for ExpressionStatement {
    fn as_node(&self) -> Node {
        Node::ExpressionStatement(self)
    }
}

impl Spanned for ExpressionStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct GlobalStatement {
    pub id: NodeId,
    pub span: Span,
    pub global: Span,
    pub variables: Vec<Variable>,
    pub semicolon: Span,
}

impl Nodeable for GlobalStatement {
    fn as_node(&self) -> Node {
        Node::GlobalStatement(self)
    }
}

impl Spanned for GlobalStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BlockStatement {
    pub id: NodeId,
    pub span: Span,
    pub left_brace: Span,
    pub statements: Vec<Statement>,
    pub right_brace: Span,
}

impl Nodeable for BlockStatement {
    fn as_node(&self) -> Node {
        Node::BlockStatement(self)
    }
}

impl Spanned for BlockStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum CastKind {
    Int(Span),
    Bool(Span),
    Float(Span),
    String(Span),
    Array(Span),
    Object(Span),
    Unset(Span),
}

impl Nodeable for CastKind {
    fn as_node(&self) -> Node {
        Node::CastKind(self)
    }
}

impl Spanned for CastKind {
    fn span(&self) -> Span {
        match self {
            CastKind::Int(span) => *span,
            CastKind::Bool(span) => *span,
            CastKind::Float(span) => *span,
            CastKind::String(span) => *span,
            CastKind::Array(span) => *span,
            CastKind::Object(span) => *span,
            CastKind::Unset(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Case {
    pub id: NodeId,
    pub span: Span,
    pub condition: Option<Expression>,
    pub body: Block,
}

impl Nodeable for Case {
    fn as_node(&self) -> Node {
        Node::Case(self)
    }
}

impl Spanned for Case {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Use {
    pub id: NodeId,
    pub name: Name,
    pub alias: Option<SimpleIdentifier>,
    pub kind: Option<UseKind>,
}

impl Nodeable for Use {
    fn as_node(&self) -> Node {
        Node::Use(self)
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Hash, Copy)]
pub enum UseKind {
    Normal,
    Function,
    Const,
}

impl Nodeable for UseKind {
    fn as_node(&self) -> Node {
        Node::UseKind(self)
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct EvalExpression {
    pub id: NodeId,
    pub span: Span,
    pub eval: Span,
    pub argument: Box<SingleArgument>,
}

impl Nodeable for EvalExpression {
    fn as_node(&self) -> Node {
        Node::EvalExpression(self)
    }
}

impl Spanned for EvalExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct EmptyExpression {
    pub id: NodeId,
    pub span: Span,
    pub empty: Span,
    pub argument: Box<SingleArgument>,
}

impl Nodeable for EmptyExpression {
    fn as_node(&self) -> Node {
        Node::EmptyExpression(self)
    }
}

impl Spanned for EmptyExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DieExpression {
    pub id: NodeId,
    pub span: Span,
    pub die: Span,
    pub argument: Option<Box<SingleArgument>>,
}

impl Nodeable for DieExpression {
    fn as_node(&self) -> Node {
        Node::DieExpression(self)
    }
}

impl Spanned for DieExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ExitExpression {
    pub id: NodeId,
    pub span: Span,
    pub exit: Span,
    pub argument: Option<Box<SingleArgument>>,
}

impl Nodeable for ExitExpression {
    fn as_node(&self) -> Node {
        Node::ExitExpression(self)
    }
}

impl Spanned for ExitExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IssetExpression {
    pub id: NodeId,
    pub span: Span,
    pub isset: Span,
    pub arguments: ArgumentList,
}

impl Nodeable for IssetExpression {
    fn as_node(&self) -> Node {
        Node::IssetExpression(self)
    }
}

impl Spanned for IssetExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct UnsetExpression {
    pub id: NodeId,
    pub span: Span,
    pub unset: Span,
    pub arguments: ArgumentList,
}

impl Nodeable for UnsetExpression {
    fn as_node(&self) -> Node {
        Node::UnsetExpression(self)
    }
}

impl Spanned for UnsetExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct PrintExpression {
    pub id: NodeId,
    pub span: Span,
    pub print: Span,
    pub value: Option<Box<Expression>>,
    pub argument: Option<Box<SingleArgument>>,
}

impl Nodeable for PrintExpression {
    fn as_node(&self) -> Node {
        Node::PrintExpression(self)
    }
}

impl Spanned for PrintExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConcatExpression {
    pub id: NodeId,
    pub span: Span,
    pub left: Box<Expression>,
    pub dot: Span,
    pub right: Box<Expression>,
}

impl Nodeable for ConcatExpression {
    fn as_node(&self) -> Node {
        Node::ConcatExpression(self)
    }
}

impl Spanned for ConcatExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct InstanceofExpression {
    pub id: NodeId,
    pub span: Span,
    pub left: Box<Expression>,
    pub instanceof: Span,
    pub right: Box<Expression>,
}

impl Nodeable for InstanceofExpression {
    fn as_node(&self) -> Node {
        Node::InstanceofExpression(self)
    }
}

impl Spanned for InstanceofExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ReferenceExpression {
    pub id: NodeId,
    pub span: Span,
    pub ampersand: Span,
    pub right: Box<Expression>,
}

impl Nodeable for ReferenceExpression {
    fn as_node(&self) -> Node {
        Node::ReferenceExpression(self)
    }
}

impl Spanned for ReferenceExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ParenthesizedExpression {
    pub id: NodeId,
    pub span: Span,
    pub start: Span,
    pub expr: Box<Expression>,
    pub end: Span,
}

impl Nodeable for ParenthesizedExpression {
    fn as_node(&self) -> Node {
        Node::ParenthesizedExpression(self)
    }
}

impl Spanned for ParenthesizedExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ErrorSuppressExpression {
    pub id: NodeId,
    pub span: Span,
    pub at: Span,
    pub expr: Box<Expression>,
}

impl Nodeable for ErrorSuppressExpression {
    fn as_node(&self) -> Node {
        Node::ErrorSuppressExpression(self)
    }
}

impl Spanned for ErrorSuppressExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IncludeExpression {
    pub id: NodeId,
    pub span: Span,
    pub include: Span,
    pub path: Box<Expression>,
}

impl Nodeable for IncludeExpression {
    fn as_node(&self) -> Node {
        Node::IncludeExpression(self)
    }
}

impl Spanned for IncludeExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IncludeOnceExpression {
    pub id: NodeId,
    pub span: Span,
    pub include_once: Span,
    pub path: Box<Expression>,
}

impl Nodeable for IncludeOnceExpression {
    fn as_node(&self) -> Node {
        Node::IncludeOnceExpression(self)
    }
}

impl Spanned for IncludeOnceExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct RequireExpression {
    pub id: NodeId,
    pub span: Span,
    pub require: Span,
    pub path: Box<Expression>,
}

impl Nodeable for RequireExpression {
    fn as_node(&self) -> Node {
        Node::RequireExpression(self)
    }
}

impl Spanned for RequireExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct RequireOnceExpression {
    pub id: NodeId,
    pub span: Span,
    pub require_once: Span,
    pub path: Box<Expression>,
}

impl Nodeable for RequireOnceExpression {
    fn as_node(&self) -> Node {
        Node::RequireOnceExpression(self)
    }
}

impl Spanned for RequireOnceExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FunctionCallExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub arguments: ArgumentList,
}

impl Nodeable for FunctionCallExpression {
    fn as_node(&self) -> Node {
        Node::FunctionCallExpression(self)
    }
}

impl Spanned for FunctionCallExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FunctionClosureCreationExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub placeholder: ArgumentPlaceholder,
}

impl Nodeable for FunctionClosureCreationExpression {
    fn as_node(&self) -> Node {
        Node::FunctionClosureCreationExpression(self)
    }
}

impl Spanned for FunctionClosureCreationExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MethodCallExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub arrow: Span,
    pub method: Box<Expression>,
    pub arguments: ArgumentList,
}

impl Nodeable for MethodCallExpression {
    fn as_node(&self) -> Node {
        Node::MethodCallExpression(self)
    }
}

impl Spanned for MethodCallExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MethodClosureCreationExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub arrow: Span,
    pub method: Box<Expression>,
    pub placeholder: ArgumentPlaceholder,
}

impl Nodeable for MethodClosureCreationExpression {
    fn as_node(&self) -> Node {
        Node::MethodClosureCreationExpression(self)
    }
}

impl Spanned for MethodClosureCreationExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct NullsafeMethodCallExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub question_arrow: Span,
    pub method: Box<Expression>,
    pub arguments: ArgumentList,
}

impl Nodeable for NullsafeMethodCallExpression {
    fn as_node(&self) -> Node {
        Node::NullsafeMethodCallExpression(self)
    }
}

impl Spanned for NullsafeMethodCallExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct StaticMethodCallExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub double_colon: Span,
    pub method: Identifier,
    pub arguments: ArgumentList,
}

impl Nodeable for StaticMethodCallExpression {
    fn as_node(&self) -> Node {
        Node::StaticMethodCallExpression(self)
    }
}

impl Spanned for StaticMethodCallExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct StaticVariableMethodCallExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub double_colon: Span,
    pub method: Variable,
    pub arguments: ArgumentList,
}

impl Nodeable for StaticVariableMethodCallExpression {
    fn as_node(&self) -> Node {
        Node::StaticVariableMethodCallExpression(self)
    }
}

impl Spanned for StaticVariableMethodCallExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct StaticMethodClosureCreationExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub double_colon: Span,
    pub method: Identifier,
    pub placeholder: ArgumentPlaceholder,
}

impl Nodeable for StaticMethodClosureCreationExpression {
    fn as_node(&self) -> Node {
        Node::StaticMethodClosureCreationExpression(self)
    }
}

impl Spanned for StaticMethodClosureCreationExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct StaticVariableMethodClosureCreationExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub double_colon: Span,
    pub method: Variable,
    pub placeholder: ArgumentPlaceholder,
}

impl Nodeable for StaticVariableMethodClosureCreationExpression {
    fn as_node(&self) -> Node {
        Node::StaticVariableMethodClosureCreationExpression(self)
    }
}

impl Spanned for StaticVariableMethodClosureCreationExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct PropertyFetchExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub arrow: Span,
    pub property: Box<Expression>,
}

impl Nodeable for PropertyFetchExpression {
    fn as_node(&self) -> Node {
        Node::PropertyFetchExpression(self)
    }
}

impl Spanned for PropertyFetchExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct NullsafePropertyFetchExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub question_arrow: Span,
    pub property: Box<Expression>,
}

impl Nodeable for NullsafePropertyFetchExpression {
    fn as_node(&self) -> Node {
        Node::NullsafePropertyFetchExpression(self)
    }
}

impl Spanned for NullsafePropertyFetchExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct StaticPropertyFetchExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub double_colon: Span,
    pub property: Variable,
}

impl Nodeable for StaticPropertyFetchExpression {
    fn as_node(&self) -> Node {
        Node::StaticPropertyFetchExpression(self)
    }
}

impl Spanned for StaticPropertyFetchExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConstantFetchExpression {
    pub id: NodeId,
    pub span: Span,
    pub target: Box<Expression>,
    pub double_colon: Span,
    pub constant: Identifier,
}

impl Nodeable for ConstantFetchExpression {
    fn as_node(&self) -> Node {
        Node::ConstantFetchExpression(self)
    }
}

impl Spanned for ConstantFetchExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ShortArrayExpression {
    pub id: NodeId,
    pub span: Span,
    pub start: Span,
    pub items: CommaSeparated<ArrayItem>,
    pub end: Span,
}

impl Nodeable for ShortArrayExpression {
    fn as_node(&self) -> Node {
        Node::ShortArrayExpression(self)
    }
}

impl Spanned for ShortArrayExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArrayExpression {
    pub id: NodeId,
    pub span: Span,
    pub array: Span,
    pub start: Span,
    pub items: CommaSeparated<ArrayItem>,
    pub end: Span,
}

impl Nodeable for ArrayExpression {
    fn as_node(&self) -> Node {
        Node::ArrayExpression(self)
    }
}

impl Spanned for ArrayExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ListExpression {
    pub id: NodeId,
    pub span: Span,
    pub list: Span,
    pub start: Span,
    pub items: Vec<ListEntry>,
    pub end: Span,
}

impl Nodeable for ListExpression {
    fn as_node(&self) -> Node {
        Node::ListExpression(self)
    }
}

impl Spanned for ListExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct NewExpression {
    pub id: NodeId,
    pub span: Span,
    pub new: Span,
    pub target: Box<Expression>,
    pub arguments: Option<ArgumentList>,
}

impl Nodeable for NewExpression {
    fn as_node(&self) -> Node {
        Node::NewExpression(self)
    }
}

impl Spanned for NewExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct InterpolatedStringExpression {
    pub id: NodeId,
    pub span: Span,
    pub parts: Vec<StringPart>,
}

impl Nodeable for InterpolatedStringExpression {
    fn as_node(&self) -> Node {
        Node::InterpolatedStringExpression(self)
    }
}

impl Spanned for InterpolatedStringExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct HeredocExpression {
    pub id: NodeId,
    pub span: Span,
    pub label: Symbol,
    pub parts: Vec<StringPart>,
}

impl Nodeable for HeredocExpression {
    fn as_node(&self) -> Node {
        Node::HeredocExpression(self)
    }
}

impl Spanned for HeredocExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct NowdocExpression {
    pub id: NodeId,
    pub span: Span,
    pub label: Token,
    pub value: Token,
}

impl Nodeable for NowdocExpression {
    fn as_node(&self) -> Node {
        Node::NowdocExpression(self)
    }
}

impl Spanned for NowdocExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ShellExecExpression {
    pub id: NodeId,
    pub span: Span,
    pub parts: Vec<StringPart>,
}

impl Nodeable for ShellExecExpression {
    fn as_node(&self) -> Node {
        Node::ShellExecExpression(self)
    }
}

impl Spanned for ShellExecExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BoolExpression {
    pub id: NodeId,
    pub span: Span,
    pub value: Token,
}

impl Nodeable for BoolExpression {
    fn as_node(&self) -> Node {
        Node::BoolExpression(self)
    }
}

impl Spanned for BoolExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArrayIndexExpression {
    pub id: NodeId,
    pub span: Span,
    pub array: Box<Expression>,
    pub left_bracket: Span,
    pub index: Option<Box<Expression>>,
    pub right_bracket: Span,
}

impl Nodeable for ArrayIndexExpression {
    fn as_node(&self) -> Node {
        Node::ArrayIndexExpression(self)
    }
}

impl Spanned for ArrayIndexExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ShortTernaryExpression {
    pub id: NodeId,
    pub span: Span,
    pub condition: Box<Expression>,
    pub question_colon: Span,
    pub r#else: Box<Expression>,
}

impl Nodeable for ShortTernaryExpression {
    fn as_node(&self) -> Node {
        Node::ShortTernaryExpression(self)
    }
}

impl Spanned for ShortTernaryExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TernaryExpression {
    pub id: NodeId,
    pub span: Span,
    pub condition: Box<Expression>,
    pub question: Span,
    pub then: Box<Expression>,
    pub colon: Span,
    pub r#else: Box<Expression>,
}

impl Nodeable for TernaryExpression {
    fn as_node(&self) -> Node {
        Node::TernaryExpression(self)
    }
}

impl Spanned for TernaryExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct CoalesceExpression {
    pub id: NodeId,
    pub span: Span,
    pub lhs: Box<Expression>,
    pub double_question: Span,
    pub rhs: Box<Expression>,
}

impl Nodeable for CoalesceExpression {
    fn as_node(&self) -> Node {
        Node::CoalesceExpression(self)
    }
}

impl Spanned for CoalesceExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct CloneExpression {
    pub id: NodeId,
    pub span: Span,
    pub clone: Span,
    pub target: Box<Expression>,
}

impl Nodeable for CloneExpression {
    fn as_node(&self) -> Node {
        Node::CloneExpression(self)
    }
}

impl Spanned for CloneExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MatchExpression {
    pub id: NodeId,
    pub span: Span,
    pub keyword: Span,
    pub left_parenthesis: Span,
    pub condition: Box<Expression>,
    pub right_parenthesis: Span,
    pub left_brace: Span,
    pub default: Option<Box<DefaultMatchArm>>,
    pub arms: Vec<MatchArm>,
    pub right_brace: Span,
}

impl Nodeable for MatchExpression {
    fn as_node(&self) -> Node {
        Node::MatchExpression(self)
    }
}

impl Spanned for MatchExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ThrowExpression {
    pub id: NodeId,
    pub span: Span,
    pub value: Box<Expression>,
}

impl Nodeable for ThrowExpression {
    fn as_node(&self) -> Node {
        Node::ThrowExpression(self)
    }
}

impl Spanned for ThrowExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct YieldExpression {
    pub id: NodeId,
    pub span: Span,
    pub r#yield: Span,
    pub key: Option<Box<Expression>>,
    pub value: Option<Box<Expression>>,
}

impl Nodeable for YieldExpression {
    fn as_node(&self) -> Node {
        Node::YieldExpression(self)
    }
}

impl Spanned for YieldExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct YieldFromExpression {
    pub id: NodeId,
    pub span: Span,
    pub r#yield: Span,
    pub from: Span,
    pub value: Box<Expression>,
}

impl Nodeable for YieldFromExpression {
    fn as_node(&self) -> Node {
        Node::YieldFromExpression(self)
    }
}

impl Spanned for YieldFromExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct CastExpression {
    pub id: NodeId,
    pub span: Span,
    pub kind: CastKind,
    pub value: Box<Expression>,
}

impl Nodeable for CastExpression {
    fn as_node(&self) -> Node {
        Node::CastExpression(self)
    }
}

impl Spanned for CastExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DefaultMatchArm {
    pub id: NodeId,
    pub span: Span,
    pub keyword: Span,
    pub double_arrow: Span,
    pub body: Expression,
}

impl Nodeable for DefaultMatchArm {
    fn as_node(&self) -> Node {
        Node::DefaultMatchArm(self)
    }
}

impl Spanned for DefaultMatchArm {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MatchArm {
    pub id: NodeId,
    pub span: Span,
    pub conditions: Vec<Expression>,
    pub arrow: Span,
    pub body: Expression,
}

impl Nodeable for MatchArm {
    fn as_node(&self) -> Node {
        Node::MatchArm(self)
    }
}

impl Spanned for MatchArm {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum MagicConstantExpression {
    Directory(Span),
    File(Span),
    Line(Span),
    Function(Span),
    Class(Span),
    Method(Span),
    Namespace(Span),
    Trait(Span),
    CompilerHaltOffset(Span),
}

impl Nodeable for MagicConstantExpression {
    fn as_node(&self) -> Node {
        Node::MagicConstantExpression(self)
    }
}

impl Spanned for MagicConstantExpression {
    fn span(&self) -> Span {
        match self {
            MagicConstantExpression::Directory(span) => *span,
            MagicConstantExpression::File(span) => *span,
            MagicConstantExpression::Line(span) => *span,
            MagicConstantExpression::Function(span) => *span,
            MagicConstantExpression::Class(span) => *span,
            MagicConstantExpression::Method(span) => *span,
            MagicConstantExpression::Namespace(span) => *span,
            MagicConstantExpression::Trait(span) => *span,
            MagicConstantExpression::CompilerHaltOffset(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum StringPart {
    Literal(LiteralStringPart),
    Expression(ExpressionStringPart),
}

impl Nodeable for StringPart {
    fn as_node(&self) -> Node {
        Node::StringPart(self)
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct LiteralStringPart {
    pub id: NodeId,
    pub span: Span,
    pub value: Symbol,
}

impl Nodeable for LiteralStringPart {
    fn as_node(&self) -> Node {
        Node::LiteralStringPart(self)
    }
}

impl Spanned for LiteralStringPart {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ExpressionStringPart {
    pub id: NodeId,
    pub span: Span,
    pub expression: Box<Expression>,
}

impl Nodeable for ExpressionStringPart {
    fn as_node(&self) -> Node {
        Node::ExpressionStringPart(self)
    }
}

impl Spanned for ExpressionStringPart {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ArrayItem {
    Skipped(Span),
    Value(ArrayItemValue),
    ReferencedValue(ArrayItemReferencedValue),
    SpreadValue(ArrayItemSpreadValue),
    KeyValue(ArrayItemKeyValue),
    ReferencedKeyValue(ArrayItemReferencedKeyValue),
}

impl Nodeable for ArrayItem {
    fn as_node(&self) -> Node {
        Node::ArrayItem(self)
    }
}

impl Spanned for ArrayItem {
    fn span(&self) -> Span {
        match self {
            ArrayItem::Skipped(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArrayItemValue {
    pub id: NodeId,
    pub span: Span,
    pub value: Expression,
}

impl Nodeable for ArrayItemValue {
    fn as_node(&self) -> Node {
        Node::ArrayItemValue(self)
    }
}

impl Spanned for ArrayItemValue {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArrayItemReferencedValue {
    pub id: NodeId,
    pub span: Span,
    pub ampersand: Span,
    pub value: Expression,
}

impl Nodeable for ArrayItemReferencedValue {
    fn as_node(&self) -> Node {
        Node::ArrayItemReferencedValue(self)
    }
}

impl Spanned for ArrayItemReferencedValue {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArrayItemSpreadValue {
    pub id: NodeId,
    pub span: Span,
    pub ellipsis: Span,
    pub value: Expression,
}

impl Nodeable for ArrayItemSpreadValue {
    fn as_node(&self) -> Node {
        Node::ArrayItemSpreadValue(self)
    }
}

impl Spanned for ArrayItemSpreadValue {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArrayItemKeyValue {
    pub id: NodeId,
    pub span: Span,
    pub key: Expression,
    pub double_arrow: Span,
    pub value: Expression,
}

impl Nodeable for ArrayItemKeyValue {
    fn as_node(&self) -> Node {
        Node::ArrayItemKeyValue(self)
    }
}

impl Spanned for ArrayItemKeyValue {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArrayItemReferencedKeyValue {
    pub id: NodeId,
    pub span: Span,
    pub key: Expression,
    pub double_arrow: Span,
    pub ampersand: Span,
    pub value: Expression,
}

impl Nodeable for ArrayItemReferencedKeyValue {
    fn as_node(&self) -> Node {
        Node::ArrayItemReferencedKeyValue(self)
    }
}

impl Spanned for ArrayItemReferencedKeyValue {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ListEntry {
    Skipped(Span),
    Value(ListEntryValue),
    KeyValue(ListEntryKeyValue),
}

impl Nodeable for ListEntry {
    fn as_node(&self) -> Node {
        Node::ListEntry(self)
    }
}

impl Spanned for ListEntry {
    fn span(&self) -> Span {
        match self {
            ListEntry::Skipped(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ListEntryValue {
    pub id: NodeId,
    pub span: Span,
    pub value: Expression,
}

impl Nodeable for ListEntryValue {
    fn as_node(&self) -> Node {
        Node::ListEntryValue(self)
    }
}

impl Spanned for ListEntryValue {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ListEntryKeyValue {
    pub id: NodeId,
    pub span: Span,
    pub key: Expression,
    pub double_arrow: Span,
    pub value: Expression,
}

impl Nodeable for ListEntryKeyValue {
    fn as_node(&self) -> Node {
        Node::ListEntryKeyValue(self)
    }
}

impl Spanned for ListEntryKeyValue {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct PositionalArgument {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub ellipsis: Option<Span>,
    pub value: Expression,
}

impl Nodeable for PositionalArgument {
    fn as_node(&self) -> Node {
        Node::PositionalArgument(self)
    }
}

impl Spanned for PositionalArgument {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct NamedArgument {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub name: SimpleIdentifier,
    pub colon: Span,
    pub ellipsis: Option<Span>,
    pub value: Expression,
}

impl Nodeable for NamedArgument {
    fn as_node(&self) -> Node {
        Node::NamedArgument(self)
    }
}

impl Spanned for NamedArgument {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Argument {
    Positional(PositionalArgument),
    Named(NamedArgument),
}

impl Nodeable for Argument {
    fn as_node(&self) -> Node {
        Node::Argument(self)
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArgumentList {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub left_parenthesis: Span,
    pub arguments: Vec<Argument>,
    pub right_parenthesis: Span,
}

impl Nodeable for ArgumentList {
    fn as_node(&self) -> Node {
        Node::ArgumentList(self)
    }
}

impl Spanned for ArgumentList {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct SingleArgument {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub left_parenthesis: Span,
    pub argument: Option<Argument>,
    pub right_parenthesis: Span,
}

impl Nodeable for SingleArgument {
    fn as_node(&self) -> Node {
        Node::SingleArgument(self)
    }
}

impl Spanned for SingleArgument {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArgumentPlaceholder {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub left_parenthesis: Span,
    pub ellipsis: Span,
    pub right_parenthesis: Span,
}

impl Nodeable for ArgumentPlaceholder {
    fn as_node(&self) -> Node {
        Node::ArgumentPlaceholder(self)
    }
}

impl Spanned for ArgumentPlaceholder {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Attribute {
    pub id: NodeId,
    pub span: Span,
    pub name: Name,
    pub arguments: Option<ArgumentList>,
}

impl Nodeable for Attribute {
    fn as_node(&self) -> Node {
        Node::Attribute(self)
    }
}

impl Spanned for Attribute {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct AttributeGroup {
    pub id: NodeId,
    pub span: Span,
    pub members: Vec<Attribute>,
}

impl Nodeable for AttributeGroup {
    fn as_node(&self) -> Node {
        Node::AttributeGroup(self)
    }
}

impl Spanned for AttributeGroup {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClassBody {
    pub id: NodeId,
    pub span: Span,
    pub left_brace: Span,
    pub members: Vec<ClassishMember>,
    pub right_brace: Span,
}

impl Nodeable for ClassBody {
    fn as_node(&self) -> Node {
        Node::ClassBody(self)
    }
}

impl Spanned for ClassBody {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClassStatement {
    pub id: NodeId,
    pub span: Span,
    pub attributes: Vec<AttributeGroup>,
    pub modifiers: ClassModifierGroup,
    pub class: Span,
    pub name: Name,
    pub extends: Option<ClassExtends>,
    pub implements: Option<ClassImplements>,
    pub body: ClassBody,
}

impl Nodeable for ClassStatement {
    fn as_node(&self) -> Node {
        Node::ClassStatement(self)
    }
}

impl Spanned for ClassStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct AnonymousClassBody {
    pub id: NodeId,
    pub span: Span,
    pub left_brace: Span,
    pub members: Vec<ClassishMember>,
    pub right_brace: Span,
}

impl Nodeable for AnonymousClassBody {
    fn as_node(&self) -> Node {
        Node::AnonymousClassBody(self)
    }
}

impl Spanned for AnonymousClassBody {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct AnonymousClassExpression {
    pub id: NodeId,
    pub span: Span,
    pub attributes: Vec<AttributeGroup>,
    pub class: Span,
    pub extends: Option<ClassExtends>,
    pub implements: Option<ClassImplements>,
    pub body: AnonymousClassBody,
}

impl Nodeable for AnonymousClassExpression {
    fn as_node(&self) -> Node {
        Node::AnonymousClassExpression(self)
    }
}

impl Spanned for AnonymousClassExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClassExtends {
    pub id: NodeId,
    pub span: Span,
    pub extends: Span,
    pub parent: Name,
}

impl Nodeable for ClassExtends {
    fn as_node(&self) -> Node {
        Node::ClassExtends(self)
    }
}

impl Spanned for ClassExtends {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClassImplements {
    pub id: NodeId,
    pub span: Span,
    pub implements: Span,
    pub interfaces: CommaSeparated<Name>,
}

impl Nodeable for ClassImplements {
    fn as_node(&self) -> Node {
        Node::ClassImplements(self)
    }
}

impl Spanned for ClassImplements {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ClassishMember {
    Constant(ClassishConstant),
    TraitUsage(TraitUsage),
    Property(Property),
    VariableProperty(VariableProperty),
    AbstractMethod(AbstractMethod),
    AbstractConstructor(AbstractConstructor),
    ConcreteMethod(ConcreteMethod),
    ConcreteConstructor(ConcreteConstructor),
}

impl Nodeable for ClassishMember {
    fn as_node(&self) -> Node {
        Node::ClassishMember(self)
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConstantEntry {
    pub id: NodeId,
    pub span: Span,
    pub name: Name,
    pub equals: Span,
    pub value: Expression,
}

impl Nodeable for ConstantEntry {
    fn as_node(&self) -> Node {
        Node::ConstantEntry(self)
    }
}

impl Spanned for ConstantEntry {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClassishConstantEntry {
    pub id: NodeId,
    pub span: Span,
    pub name: SimpleIdentifier,
    pub equals: Span,
    pub value: Expression,
}

impl Nodeable for ClassishConstantEntry {
    fn as_node(&self) -> Node {
        Node::ClassishConstantEntry(self)
    }
}

impl Spanned for ClassishConstantEntry {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConstantStatement {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub r#const: Span,
    pub entries: Vec<ConstantEntry>,
    pub semicolon: Span,
}

impl Nodeable for ConstantStatement {
    fn as_node(&self) -> Node {
        Node::ConstantStatement(self)
    }
}

impl Spanned for ConstantStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClassishConstant {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub attributes: Vec<AttributeGroup>,
    pub modifiers: ConstantModifierGroup,
    pub r#const: Span,
    pub data_type: Option<DataType>,
    pub entries: Vec<ClassishConstantEntry>,
    pub semicolon: Span,
}

impl Nodeable for ClassishConstant {
    fn as_node(&self) -> Node {
        Node::ClassishConstant(self)
    }
}

impl Spanned for ClassishConstant {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IfStatement {
    pub id: NodeId,
    pub span: Span,
    pub r#if: Span,
    pub left_parenthesis: Span,
    pub condition: Expression,
    pub right_parenthesis: Span,
    pub body: IfStatementBody,
}

impl Nodeable for IfStatement {
    fn as_node(&self) -> Node {
        Node::IfStatement(self)
    }
}

impl Spanned for IfStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum IfStatementBody {
    Statement {
        span: Span,
        statement: Box<Statement>,
        elseifs: Vec<IfStatementElseIf>,
        r#else: Option<IfStatementElse>,
    },
    Block {
        span: Span,
        colon: Span,
        statements: Vec<Statement>,
        elseifs: Vec<IfStatementElseIfBlock>,
        r#else: Option<IfStatementElseBlock>,
        endif: Span,
        ending: Ending,
    },
}

impl Nodeable for IfStatementBody {
    fn as_node(&self) -> Node {
        Node::IfStatementBody(self)
    }
}

impl Spanned for IfStatementBody {
    fn span(&self) -> Span {
        match self {
            IfStatementBody::Statement { span, .. } => *span,
            IfStatementBody::Block { span, .. } => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IfStatementElseIf {
    pub id: NodeId,
    pub span: Span,
    pub elseif: Span,
    pub left_parenthesis: Span,
    pub condition: Expression,
    pub right_parenthesis: Span,
    pub statement: Box<Statement>,
}

impl Nodeable for IfStatementElseIf {
    fn as_node(&self) -> Node {
        Node::IfStatementElseIf(self)
    }
}

impl Spanned for IfStatementElseIf {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IfStatementElse {
    pub id: NodeId,
    pub span: Span,
    pub r#else: Span,
    pub statement: Box<Statement>,
}

impl Nodeable for IfStatementElse {
    fn as_node(&self) -> Node {
        Node::IfStatementElse(self)
    }
}

impl Spanned for IfStatementElse {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IfStatementElseIfBlock {
    pub id: NodeId,
    pub span: Span,
    pub elseif: Span,
    pub left_parenthesis: Span,
    pub condition: Expression,
    pub right_parenthesis: Span,
    pub colon: Span,
    pub statements: Vec<Statement>,
}

impl Nodeable for IfStatementElseIfBlock {
    fn as_node(&self) -> Node {
        Node::IfStatementElseIfBlock(self)
    }
}

impl Spanned for IfStatementElseIfBlock {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct IfStatementElseBlock {
    pub id: NodeId,
    pub span: Span,
    pub r#else: Span,
    pub colon: Span,
    pub statements: Vec<Statement>,
}

impl Nodeable for IfStatementElseBlock {
    fn as_node(&self) -> Node {
        Node::IfStatementElseBlock(self)
    }
}

impl Spanned for IfStatementElseBlock {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DataType {
    pub id: NodeId,
    pub kind: Type<Name>,
    pub span: Span,
}

impl Nodeable for DataType {
    fn as_node(&self) -> Node {
        Node::DataType(self)
    }
}

impl Spanned for DataType {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DeclareEntry {
    pub id: NodeId,
    pub span: Span,
    pub key: SimpleIdentifier,
    pub equals: Span,
    pub value: Literal,
}

impl Nodeable for DeclareEntry {
    fn as_node(&self) -> Node {
        Node::DeclareEntry(self)
    }
}

impl Spanned for DeclareEntry {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DeclareEntryGroup {
    pub id: NodeId,
    pub span: Span,
    pub left_parenthesis: Span,
    pub right_parenthesis: Span,
    pub entries: Vec<DeclareEntry>,
}

impl Nodeable for DeclareEntryGroup {
    fn as_node(&self) -> Node {
        Node::DeclareEntryGroup(self)
    }
}

impl Spanned for DeclareEntryGroup {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum DeclareBody {
    Noop {
        span: Span,
        semicolon: Span,
    },
    Braced {
        span: Span,
        left_brace: Span,
        statements: Vec<Statement>,
        right_brace: Span,
    },
    Expression {
        span: Span,
        expression: Expression,
        semicolon: Span,
    },
    Block {
        span: Span,
        colon: Span,
        statements: Vec<Statement>,
        enddeclare: Span,
        semicolon: Span,
    },
}

impl Nodeable for DeclareBody {
    fn as_node(&self) -> Node {
        Node::DeclareBody(self)
    }
}

impl Spanned for DeclareBody {
    fn span(&self) -> Span {
        match self {
            DeclareBody::Noop { span, .. } => *span,
            DeclareBody::Braced { span, .. } => *span,
            DeclareBody::Expression { span, .. } => *span,
            DeclareBody::Block { span, .. } => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DeclareStatement {
    pub id: NodeId,
    pub span: Span,
    pub declare: Span,
    pub entries: DeclareEntryGroup,
    pub body: DeclareBody,
}

impl Nodeable for DeclareStatement {
    fn as_node(&self) -> Node {
        Node::DeclareStatement(self)
    }
}

impl Spanned for DeclareStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct UnitEnumCase {
    pub id: NodeId,
    pub span: Span,
    pub attributes: Vec<AttributeGroup>,
    pub start: Span,
    pub name: SimpleIdentifier,
    pub end: Span,
}

impl Nodeable for UnitEnumCase {
    fn as_node(&self) -> Node {
        Node::UnitEnumCase(self)
    }
}

impl Spanned for UnitEnumCase {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum UnitEnumMember {
    Case(UnitEnumCase),
    Classish(ClassishMember),
}

impl Nodeable for UnitEnumMember {
    fn as_node(&self) -> Node {
        Node::UnitEnumMember(self)
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct UnitEnumBody {
    pub id: NodeId,
    pub span: Span,
    pub left_brace: Span,
    pub members: Vec<UnitEnumMember>,
    pub right_brace: Span,
}

impl Nodeable for UnitEnumBody {
    fn as_node(&self) -> Node {
        Node::UnitEnumBody(self)
    }
}

impl Spanned for UnitEnumBody {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct UnitEnumStatement {
    pub id: NodeId,
    pub span: Span,
    pub attributes: Vec<AttributeGroup>,
    pub r#enum: Span,
    pub name: Name,
    pub implements: Vec<Name>,
    pub body: UnitEnumBody,
}

impl Nodeable for UnitEnumStatement {
    fn as_node(&self) -> Node {
        Node::UnitEnumStatement(self)
    }
}

impl Spanned for UnitEnumStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BackedEnumCase {
    pub id: NodeId,
    pub span: Span,
    pub attributes: Vec<AttributeGroup>,
    pub case: Span,
    pub name: SimpleIdentifier,
    pub equals: Span,
    pub value: Expression,
    pub semicolon: Span,
}

impl Nodeable for BackedEnumCase {
    fn as_node(&self) -> Node {
        Node::BackedEnumCase(self)
    }
}

impl Spanned for BackedEnumCase {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum BackedEnumMember {
    Case(BackedEnumCase),
    Classish(ClassishMember),
}

impl Nodeable for BackedEnumMember {
    fn as_node(&self) -> Node {
        Node::BackedEnumMember(self)
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BackedEnumBody {
    pub id: NodeId,
    pub span: Span,
    pub left_brace: Span,
    pub members: Vec<BackedEnumMember>,
    pub right_brace: Span,
}

impl Nodeable for BackedEnumBody {
    fn as_node(&self) -> Node {
        Node::BackedEnumBody(self)
    }
}

impl Spanned for BackedEnumBody {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BackedEnumStatement {
    pub id: NodeId,
    pub span: Span,
    pub attributes: Vec<AttributeGroup>,
    pub r#enum: Span,
    pub name: Name,
    pub backed_type: BackedEnumType,
    pub implements: Vec<Name>,
    pub body: BackedEnumBody,
}

impl Nodeable for BackedEnumStatement {
    fn as_node(&self) -> Node {
        Node::BackedEnumStatement(self)
    }
}

impl Spanned for BackedEnumStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ReturnType {
    pub id: NodeId,
    pub span: Span,
    pub colon: Span,
    pub data_type: DataType,
}

impl Nodeable for ReturnType {
    fn as_node(&self) -> Node {
        Node::ReturnType(self)
    }
}

impl Spanned for ReturnType {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FunctionParameter {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub name: SimpleVariable,
    pub attributes: Vec<AttributeGroup>,
    pub data_type: Option<DataType>,
    pub ellipsis: Option<Span>,
    pub default: Option<Expression>,
    pub ampersand: Option<Span>,
}

impl Nodeable for FunctionParameter {
    fn as_node(&self) -> Node {
        Node::FunctionParameter(self)
    }
}

impl Spanned for FunctionParameter {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FunctionParameterList {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub left_parenthesis: Span,
    pub parameters: CommaSeparated<FunctionParameter>,
    pub right_parenthesis: Span,
}

impl Nodeable for FunctionParameterList {
    fn as_node(&self) -> Node {
        Node::FunctionParameterList(self)
    }
}

impl Spanned for FunctionParameterList {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FunctionBody {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub left_brace: Span,
    pub statements: Vec<Statement>,
    pub right_brace: Span,
}

impl Nodeable for FunctionBody {
    fn as_node(&self) -> Node {
        Node::FunctionBody(self)
    }
}

impl Spanned for FunctionBody {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FunctionStatement {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub attributes: Vec<AttributeGroup>,
    pub function: Span,
    pub ampersand: Option<Span>,
    pub name: Name,
    pub parameters: FunctionParameterList,
    pub return_type: Option<ReturnType>,
    pub body: FunctionBody,
}

impl Nodeable for FunctionStatement {
    fn as_node(&self) -> Node {
        Node::FunctionStatement(self)
    }
}

impl Spanned for FunctionStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClosureUseVariable {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub ampersand: Option<Span>,
    pub variable: SimpleVariable,
}

impl Nodeable for ClosureUseVariable {
    fn as_node(&self) -> Node {
        Node::ClosureUseVariable(self)
    }
}

impl Spanned for ClosureUseVariable {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClosureUse {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub r#use: Span,
    pub left_parenthesis: Span,
    pub variables: CommaSeparated<ClosureUseVariable>,
    pub right_parenthesis: Span,
}

impl Nodeable for ClosureUse {
    fn as_node(&self) -> Node {
        Node::ClosureUse(self)
    }
}

impl Spanned for ClosureUse {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ClosureExpression {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub attributes: Vec<AttributeGroup>,
    pub r#static: Option<Span>,
    pub function: Span,
    pub ampersand: Option<Span>,
    pub parameters: FunctionParameterList,
    pub uses: Option<ClosureUse>,
    pub return_type: Option<ReturnType>,
    pub body: FunctionBody,
}

impl Nodeable for ClosureExpression {
    fn as_node(&self) -> Node {
        Node::ClosureExpression(self)
    }
}

impl Spanned for ClosureExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArrowFunctionExpression {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub r#static: Option<Span>,
    pub ampersand: Option<Span>,
    pub r#fn: Span,
    pub attributes: Vec<AttributeGroup>,
    pub parameters: FunctionParameterList,
    pub return_type: Option<ReturnType>,
    pub double_arrow: Span,
    pub body: Box<Expression>,
}

impl Nodeable for ArrowFunctionExpression {
    fn as_node(&self) -> Node {
        Node::ArrowFunctionExpression(self)
    }
}

impl Spanned for ArrowFunctionExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConstructorParameter {
    pub id: NodeId,
    pub span: Span,
    pub attributes: Vec<AttributeGroup>,
    pub comments: CommentGroup,
    pub ampersand: Option<Span>,
    pub name: SimpleVariable,
    pub data_type: Option<DataType>,
    pub ellipsis: Option<Span>,
    pub default: Option<Expression>,
    pub modifiers: PromotedPropertyModifierGroup,
}

impl Nodeable for ConstructorParameter {
    fn as_node(&self) -> Node {
        Node::ConstructorParameter(self)
    }
}

impl Spanned for ConstructorParameter {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConstructorParameterList {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub left_parenthesis: Span,
    pub parameters: CommaSeparated<ConstructorParameter>,
    pub right_parenthesis: Span,
}

impl Nodeable for ConstructorParameterList {
    fn as_node(&self) -> Node {
        Node::ConstructorParameterList(self)
    }
}

impl Spanned for ConstructorParameterList {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct AbstractConstructor {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub attributes: Vec<AttributeGroup>,
    pub modifiers: MethodModifierGroup,
    pub function: Span,
    pub ampersand: Option<Span>,
    pub name: SimpleIdentifier,
    pub parameters: ConstructorParameterList,
    pub semicolon: Span,
}

impl Nodeable for AbstractConstructor {
    fn as_node(&self) -> Node {
        Node::AbstractConstructor(self)
    }
}

impl Spanned for AbstractConstructor {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConcreteConstructor {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub attributes: Vec<AttributeGroup>,
    pub modifiers: MethodModifierGroup,
    pub function: Span,
    pub ampersand: Option<Span>,
    pub name: SimpleIdentifier,
    pub parameters: ConstructorParameterList,
    pub body: MethodBody,
}

impl Nodeable for ConcreteConstructor {
    fn as_node(&self) -> Node {
        Node::ConcreteConstructor(self)
    }
}

impl Spanned for ConcreteConstructor {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct AbstractMethod {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub attributes: Vec<AttributeGroup>,
    pub modifiers: MethodModifierGroup,
    pub function: Span,
    pub ampersand: Option<Span>,
    pub name: SimpleIdentifier,
    pub parameters: FunctionParameterList,
    pub return_type: Option<ReturnType>,
    pub semicolon: Span,
}

impl Nodeable for AbstractMethod {
    fn as_node(&self) -> Node {
        Node::AbstractMethod(self)
    }
}

impl Spanned for AbstractMethod {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConcreteMethod {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub attributes: Vec<AttributeGroup>,
    pub modifiers: MethodModifierGroup,
    pub function: Span,
    pub ampersand: Option<Span>,
    pub name: SimpleIdentifier,
    pub parameters: FunctionParameterList,
    pub return_type: Option<ReturnType>,
    pub body: MethodBody,
}

impl Nodeable for ConcreteMethod {
    fn as_node(&self) -> Node {
        Node::ConcreteMethod(self)
    }
}

impl Spanned for ConcreteMethod {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct MethodBody {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub left_brace: Span,
    pub statements: Vec<Statement>,
    pub right_brace: Span,
}

impl Nodeable for MethodBody {
    fn as_node(&self) -> Node {
        Node::MethodBody(self)
    }
}

impl Spanned for MethodBody {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct LabelStatement {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub label: SimpleIdentifier,
    pub colon: Span,
}

impl Nodeable for LabelStatement {
    fn as_node(&self) -> Node {
        Node::LabelStatement(self)
    }
}

impl Spanned for LabelStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct GotoStatement {
    pub id: NodeId,
    pub span: Span,
    pub comments: CommentGroup,
    pub keyword: Span,
    pub label: SimpleIdentifier,
    pub semicolon: Span,
}

impl Nodeable for GotoStatement {
    fn as_node(&self) -> Node {
        Node::GotoStatement(self)
    }
}

impl Spanned for GotoStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Identifier {
    SimpleIdentifier(SimpleIdentifier),
    DynamicIdentifier(DynamicIdentifier),
}

impl Nodeable for Identifier {
    fn as_node(&self) -> Node {
        Node::Identifier(self)
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct SimpleIdentifier {
    pub id: NodeId,
    pub symbol: Symbol,
    pub span: Span,
}

impl Nodeable for SimpleIdentifier {
    fn as_node(&self) -> Node {
        Node::SimpleIdentifier(self)
    }
}

impl Spanned for SimpleIdentifier {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DynamicIdentifier {
    pub id: NodeId,
    pub span: Span,
    pub expr: Box<Expression>,
}

impl Nodeable for DynamicIdentifier {
    fn as_node(&self) -> Node {
        Node::DynamicIdentifier(self)
    }
}

impl Spanned for DynamicIdentifier {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct InterfaceExtends {
    pub id: NodeId,
    pub span: Span,
    pub extends: Span,
    pub parents: CommaSeparated<Name>,
}

impl Nodeable for InterfaceExtends {
    fn as_node(&self) -> Node {
        Node::InterfaceExtends(self)
    }
}

impl Spanned for InterfaceExtends {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct InterfaceBody {
    pub id: NodeId,
    pub span: Span,
    pub left_brace: Span,
    pub members: Vec<ClassishMember>,
    pub right_brace: Span,
}

impl Nodeable for InterfaceBody {
    fn as_node(&self) -> Node {
        Node::InterfaceBody(self)
    }
}

impl Spanned for InterfaceBody {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct InterfaceStatement {
    pub id: NodeId,
    pub span: Span,
    pub attributes: Vec<AttributeGroup>,
    pub interface: Span,
    pub name: Name,
    pub extends: Option<InterfaceExtends>,
    pub body: InterfaceBody,
}

impl Nodeable for InterfaceStatement {
    fn as_node(&self) -> Node {
        Node::InterfaceStatement(self)
    }
}

impl Spanned for InterfaceStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Literal {
    pub id: NodeId,
    pub span: Span,
    pub kind: LiteralKind,
    pub token: Token,
}

impl Nodeable for Literal {
    fn as_node(&self) -> Node {
        Node::Literal(self)
    }
}

impl Spanned for Literal {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum LiteralKind {
    Integer,
    Float,
    String,
    Missing,
}

impl Nodeable for LiteralKind {
    fn as_node(&self) -> Node {
        Node::LiteralKind(self)
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ForeachStatement {
    pub id: NodeId,
    pub span: Span,
    pub foreach: Span,
    pub left_parenthesis: Span,
    pub iterator: ForeachStatementIterator,
    pub right_parenthesis: Span,
    pub body: ForeachStatementBody,
}

impl Nodeable for ForeachStatement {
    fn as_node(&self) -> Node {
        Node::ForeachStatement(self)
    }
}

impl Spanned for ForeachStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ForeachStatementIterator {
    Value {
        span: Span,
        expression: Expression,
        r#as: Span,
        ampersand: Option<Span>,
        value: Expression,
    },
    KeyAndValue {
        span: Span,
        expression: Expression,
        r#as: Span,
        ampersand: Option<Span>,
        key: Expression,
        double_arrow: Span,
        value: Expression,
    },
}

impl Nodeable for ForeachStatementIterator {
    fn as_node(&self) -> Node {
        Node::ForeachStatementIterator(self)
    }
}

impl Spanned for ForeachStatementIterator {
    fn span(&self) -> Span {
        match self {
            ForeachStatementIterator::Value { span, .. } => *span,
            ForeachStatementIterator::KeyAndValue { span, .. } => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ForeachStatementBody {
    Statement {
        span: Span,
        statement: Box<Statement>,
    },
    Block {
        span: Span,
        colon: Span,
        statements: Vec<Statement>,
        endforeach: Span,
        ending: Ending,
    },
}

impl Nodeable for ForeachStatementBody {
    fn as_node(&self) -> Node {
        Node::ForeachStatementBody(self)
    }
}

impl Spanned for ForeachStatementBody {
    fn span(&self) -> Span {
        match self {
            ForeachStatementBody::Statement { span, .. } => *span,
            ForeachStatementBody::Block { span, .. } => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ForStatement {
    pub id: NodeId,
    pub span: Span,
    pub r#for: Span,
    pub left_parenthesis: Span,
    pub iterator: ForStatementIterator,
    pub right_parenthesis: Span,
    pub body: ForStatementBody,
}

impl Nodeable for ForStatement {
    fn as_node(&self) -> Node {
        Node::ForStatement(self)
    }
}

impl Spanned for ForStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ForStatementIterator {
    pub id: NodeId,
    pub span: Span,
    pub initializations: CommaSeparated<Expression>,
    pub initializations_semicolon: Span,
    pub conditions: CommaSeparated<Expression>,
    pub conditions_semicolon: Span,
    pub r#loop: CommaSeparated<Expression>,
}

impl Nodeable for ForStatementIterator {
    fn as_node(&self) -> Node {
        Node::ForStatementIterator(self)
    }
}

impl Spanned for ForStatementIterator {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ForStatementBody {
    Statement {
        span: Span,
        statement: Box<Statement>,
    },
    Block {
        span: Span,
        colon: Span,
        statements: Vec<Statement>,
        endfor: Span,
        ending: Ending,
    },
}

impl Nodeable for ForStatementBody {
    fn as_node(&self) -> Node {
        Node::ForStatementBody(self)
    }
}

impl Spanned for ForStatementBody {
    fn span(&self) -> Span {
        match self {
            ForStatementBody::Statement { span, .. } => *span,
            ForStatementBody::Block { span, .. } => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct DoWhileStatement {
    pub id: NodeId,
    pub span: Span,
    pub r#do: Span,
    pub body: Box<Statement>,
    pub r#while: Span,
    pub left_parenthesis: Span,
    pub condition: Expression,
    pub right_parenthesis: Span,
    pub semicolon: Span,
}

impl Nodeable for DoWhileStatement {
    fn as_node(&self) -> Node {
        Node::DoWhileStatement(self)
    }
}

impl Spanned for DoWhileStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct WhileStatement {
    pub id: NodeId,
    pub span: Span,
    pub r#while: Span,
    pub left_parenthesis: Span,
    pub condition: Expression,
    pub right_parenthesis: Span,
    pub body: WhileStatementBody,
}

impl Nodeable for WhileStatement {
    fn as_node(&self) -> Node {
        Node::WhileStatement(self)
    }
}

impl Spanned for WhileStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum WhileStatementBody {
    Statement {
        span: Span,
        statement: Box<Statement>,
    },
    Block {
        span: Span,
        colon: Span,
        statements: Vec<Statement>,
        endwhile: Span,
        ending: Ending,
    },
}

impl Nodeable for WhileStatementBody {
    fn as_node(&self) -> Node {
        Node::WhileStatementBody(self)
    }
}

impl Spanned for WhileStatementBody {
    fn span(&self) -> Span {
        match self {
            WhileStatementBody::Statement { span, .. } => *span,
            WhileStatementBody::Block { span, .. } => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Level {
    Literal(Literal),
    Parenthesized {
        span: Span,
        left_parenthesis: Span,
        level: Box<Level>,
        right_parenthesis: Span,
    },
}

impl Nodeable for Level {
    fn as_node(&self) -> Node {
        Node::Level(self)
    }
}

impl Spanned for Level {
    fn span(&self) -> Span {
        match self {
            Level::Parenthesized { span, .. } => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BreakStatement {
    pub id: NodeId,
    pub span: Span,
    pub r#break: Span,
    pub level: Option<Level>,
    pub ending: Ending,
}

impl Nodeable for BreakStatement {
    fn as_node(&self) -> Node {
        Node::BreakStatement(self)
    }
}

impl Spanned for BreakStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ContinueStatement {
    pub id: NodeId,
    pub span: Span,
    pub r#continue: Span,
    pub level: Option<Level>,
    pub ending: Ending,
}

impl Nodeable for ContinueStatement {
    fn as_node(&self) -> Node {
        Node::ContinueStatement(self)
    }
}

impl Spanned for ContinueStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum VisibilityModifier {
    Public(Span),
    Protected(Span),
    Private(Span),
}

impl Nodeable for VisibilityModifier {
    fn as_node(&self) -> Node {
        Node::VisibilityModifier(self)
    }
}

impl Spanned for VisibilityModifier {
    fn span(&self) -> Span {
        match self {
            VisibilityModifier::Public(span) => *span,
            VisibilityModifier::Protected(span) => *span,
            VisibilityModifier::Private(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum PromotedPropertyModifier {
    Public(Span),
    Protected(Span),
    Private(Span),
    Readonly(Span),
}

impl Nodeable for PromotedPropertyModifier {
    fn as_node(&self) -> Node {
        Node::PromotedPropertyModifier(self)
    }
}

impl Spanned for PromotedPropertyModifier {
    fn span(&self) -> Span {
        match self {
            PromotedPropertyModifier::Public(span) => *span,
            PromotedPropertyModifier::Protected(span) => *span,
            PromotedPropertyModifier::Private(span) => *span,
            PromotedPropertyModifier::Readonly(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Default)]
pub struct PromotedPropertyModifierGroup {
    pub id: NodeId,
    pub span: Span,
    pub modifiers: Vec<PromotedPropertyModifier>,
}

impl Nodeable for PromotedPropertyModifierGroup {
    fn as_node(&self) -> Node {
        Node::PromotedPropertyModifierGroup(self)
    }
}

impl Spanned for PromotedPropertyModifierGroup {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum PropertyModifier {
    Public(Span),
    Protected(Span),
    Private(Span),
    Static(Span),
    Readonly(Span),
}

impl Nodeable for PropertyModifier {
    fn as_node(&self) -> Node {
        Node::PropertyModifier(self)
    }
}

impl Spanned for PropertyModifier {
    fn span(&self) -> Span {
        match self {
            PropertyModifier::Public(span) => *span,
            PropertyModifier::Protected(span) => *span,
            PropertyModifier::Private(span) => *span,
            PropertyModifier::Static(span) => *span,
            PropertyModifier::Readonly(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Default)]
pub struct PropertyModifierGroup {
    pub id: NodeId,
    pub span: Span,
    pub modifiers: Vec<PropertyModifier>,
}

impl Nodeable for PropertyModifierGroup {
    fn as_node(&self) -> Node {
        Node::PropertyModifierGroup(self)
    }
}

impl Spanned for PropertyModifierGroup {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum MethodModifier {
    Public(Span),
    Protected(Span),
    Private(Span),
    Static(Span),
    Abstract(Span),
    Final(Span),
}

impl Nodeable for MethodModifier {
    fn as_node(&self) -> Node {
        Node::MethodModifier(self)
    }
}

impl Spanned for MethodModifier {
    fn span(&self) -> Span {
        match self {
            MethodModifier::Public(span) => *span,
            MethodModifier::Protected(span) => *span,
            MethodModifier::Private(span) => *span,
            MethodModifier::Static(span) => *span,
            MethodModifier::Abstract(span) => *span,
            MethodModifier::Final(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Default)]
pub struct MethodModifierGroup {
    pub id: NodeId,
    pub span: Span,
    pub modifiers: Vec<MethodModifier>,
}

impl Nodeable for MethodModifierGroup {
    fn as_node(&self) -> Node {
        Node::MethodModifierGroup(self)
    }
}

impl Spanned for MethodModifierGroup {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ClassModifier {
    Abstract(Span),
    Final(Span),
    Readonly(Span),
}

impl Nodeable for ClassModifier {
    fn as_node(&self) -> Node {
        Node::ClassModifier(self)
    }
}

impl Spanned for ClassModifier {
    fn span(&self) -> Span {
        match self {
            ClassModifier::Abstract(span) => *span,
            ClassModifier::Final(span) => *span,
            ClassModifier::Readonly(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Default)]
pub struct ClassModifierGroup {
    pub id: NodeId,
    pub span: Span,
    pub modifiers: Vec<ClassModifier>,
}

impl Nodeable for ClassModifierGroup {
    fn as_node(&self) -> Node {
        Node::ClassModifierGroup(self)
    }
}

impl Spanned for ClassModifierGroup {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ConstantModifier {
    Public(Span),
    Protected(Span),
    Private(Span),
    Final(Span),
}

impl Nodeable for ConstantModifier {
    fn as_node(&self) -> Node {
        Node::ConstantModifier(self)
    }
}

impl Spanned for ConstantModifier {
    fn span(&self) -> Span {
        match self {
            ConstantModifier::Public(span) => *span,
            ConstantModifier::Protected(span) => *span,
            ConstantModifier::Private(span) => *span,
            ConstantModifier::Final(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ConstantModifierGroup {
    pub id: NodeId,
    pub span: Span,
    pub modifiers: Vec<ConstantModifier>,
}

impl Nodeable for ConstantModifierGroup {
    fn as_node(&self) -> Node {
        Node::ConstantModifierGroup(self)
    }
}

impl Spanned for ConstantModifierGroup {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct UnbracedNamespace {
    pub id: NodeId,
    pub span: Span,
    pub start: Span,
    pub name: Name,
    pub end: Span,
    pub statements: Vec<Statement>,
}

impl Nodeable for UnbracedNamespace {
    fn as_node(&self) -> Node {
        Node::UnbracedNamespace(self)
    }
}

impl Spanned for UnbracedNamespace {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BracedNamespace {
    pub id: NodeId,
    pub span: Span,
    pub namespace: Span,
    pub name: Option<Name>,
    pub body: BracedNamespaceBody,
}

impl Nodeable for BracedNamespace {
    fn as_node(&self) -> Node {
        Node::BracedNamespace(self)
    }
}

impl Spanned for BracedNamespace {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BracedNamespaceBody {
    pub id: NodeId,
    pub span: Span,
    pub start: Span,
    pub end: Span,
    pub statements: Vec<Statement>,
}

impl Nodeable for BracedNamespaceBody {
    fn as_node(&self) -> Node {
        Node::BracedNamespaceBody(self)
    }
}

impl Spanned for BracedNamespaceBody {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum NamespaceStatement {
    Unbraced(UnbracedNamespace),
    Braced(BracedNamespace),
}

impl Nodeable for NamespaceStatement {
    fn as_node(&self) -> Node {
        Node::NamespaceStatement(self)
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ArithmeticOperationExpression {
    pub id: NodeId,
    pub span: Span,
    pub kind: ArithmeticOperationKind,
}

impl Nodeable for ArithmeticOperationExpression {
    fn as_node(&self) -> Node {
        Node::ArithmeticOperationExpression(self)
    }
}

impl Spanned for ArithmeticOperationExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ArithmeticOperationKind {
    Addition {
        left: Box<Expression>,
        plus: Span,
        right: Box<Expression>,
    },
    Subtraction {
        left: Box<Expression>,
        minus: Span,
        right: Box<Expression>,
    },
    Multiplication {
        left: Box<Expression>,
        asterisk: Span,
        right: Box<Expression>,
    },
    Division {
        left: Box<Expression>,
        slash: Span,
        right: Box<Expression>,
    },
    Modulo {
        left: Box<Expression>,
        percent: Span,
        right: Box<Expression>,
    },
    Exponentiation {
        left: Box<Expression>,
        pow: Span,
        right: Box<Expression>,
    },
    Negative {
        minus: Span,
        right: Box<Expression>,
    },
    Positive {
        plus: Span,
        right: Box<Expression>,
    },
    PreIncrement {
        increment: Span,
        right: Box<Expression>,
    },
    PostIncrement {
        left: Box<Expression>,
        increment: Span,
    },
    PreDecrement {
        decrement: Span,
        right: Box<Expression>,
    },
    PostDecrement {
        left: Box<Expression>,
        decrement: Span,
    },
}

impl Nodeable for ArithmeticOperationKind {
    fn as_node(&self) -> Node {
        Node::ArithmeticOperationKind(self)
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct AssignmentOperationExpression {
    pub id: NodeId,
    pub span: Span,
    pub kind: AssignmentOperationKind,
}

impl Nodeable for AssignmentOperationExpression {
    fn as_node(&self) -> Node {
        Node::AssignmentOperationExpression(self)
    }
}

impl Spanned for AssignmentOperationExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum AssignmentOperationKind {
    Assign {
        left: Box<Expression>,
        equals: Span,
        right: Box<Expression>,
    },
    Addition {
        left: Box<Expression>,
        plus_equals: Span,
        right: Box<Expression>,
    },
    Subtraction {
        left: Box<Expression>,
        minus_equals: Span,
        right: Box<Expression>,
    },
    Multiplication {
        left: Box<Expression>,
        asterisk_equals: Span,
        right: Box<Expression>,
    },
    Division {
        left: Box<Expression>,
        slash_equals: Span,
        right: Box<Expression>,
    },
    Modulo {
        left: Box<Expression>,
        percent_equals: Span,
        right: Box<Expression>,
    },
    Exponentiation {
        left: Box<Expression>,
        pow_equals: Span,
        right: Box<Expression>,
    },
    Concat {
        left: Box<Expression>,
        dot_equals: Span,
        right: Box<Expression>,
    },
    BitwiseAnd {
        left: Box<Expression>,
        ampersand_equals: Span,
        right: Box<Expression>,
    },
    BitwiseOr {
        left: Box<Expression>,
        pipe_equals: Span,
        right: Box<Expression>,
    },
    BitwiseXor {
        left: Box<Expression>,
        caret_equals: Span,
        right: Box<Expression>,
    },
    LeftShift {
        left: Box<Expression>,
        left_shift_equals: Span,
        right: Box<Expression>,
    },
    RightShift {
        left: Box<Expression>,
        right_shift_equals: Span,
        right: Box<Expression>,
    },
    Coalesce {
        left: Box<Expression>,
        coalesce_equals: Span,
        right: Box<Expression>,
    },
}

impl Nodeable for AssignmentOperationKind {
    fn as_node(&self) -> Node {
        Node::AssignmentOperationKind(self)
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BitwiseOperationExpression {
    pub id: NodeId,
    pub span: Span,
    pub kind: BitwiseOperationKind,
}

impl Nodeable for BitwiseOperationExpression {
    fn as_node(&self) -> Node {
        Node::BitwiseOperationExpression(self)
    }
}

impl Spanned for BitwiseOperationExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum BitwiseOperationKind {
    And {
        left: Box<Expression>,
        and: Span,
        right: Box<Expression>,
    },
    Or {
        left: Box<Expression>,
        or: Span,
        right: Box<Expression>,
    },
    Xor {
        left: Box<Expression>,
        xor: Span,
        right: Box<Expression>,
    },
    LeftShift {
        left: Box<Expression>,
        left_shift: Span,
        right: Box<Expression>,
    },
    RightShift {
        left: Box<Expression>,
        right_shift: Span,
        right: Box<Expression>,
    },
    Not {
        not: Span,
        right: Box<Expression>,
    },
}

impl Nodeable for BitwiseOperationKind {
    fn as_node(&self) -> Node {
        Node::BitwiseOperationKind(self)
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ComparisonOperationExpression {
    pub id: NodeId,
    pub span: Span,
    pub kind: ComparisonOperationKind,
}

impl Nodeable for ComparisonOperationExpression {
    fn as_node(&self) -> Node {
        Node::ComparisonOperationExpression(self)
    }
}

impl Spanned for ComparisonOperationExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum ComparisonOperationKind {
    Equal {
        left: Box<Expression>,
        double_equals: Span,
        right: Box<Expression>,
    },
    Identical {
        left: Box<Expression>,
        triple_equals: Span,
        right: Box<Expression>,
    },
    NotEqual {
        left: Box<Expression>,
        bang_equals: Span,
        right: Box<Expression>,
    },
    AngledNotEqual {
        left: Box<Expression>,
        angled_left_right: Span,
        right: Box<Expression>,
    },
    NotIdentical {
        left: Box<Expression>,
        bang_double_equals: Span,
        right: Box<Expression>,
    },
    LessThan {
        left: Box<Expression>,
        less_than: Span,
        right: Box<Expression>,
    },
    GreaterThan {
        left: Box<Expression>,
        greater_than: Span,
        right: Box<Expression>,
    },
    LessThanOrEqual {
        left: Box<Expression>,
        less_than_equals: Span,
        right: Box<Expression>,
    },
    GreaterThanOrEqual {
        left: Box<Expression>,
        greater_than_equals: Span,
        right: Box<Expression>,
    },
    Spaceship {
        left: Box<Expression>,
        spaceship: Span,
        right: Box<Expression>,
    },
}

impl Nodeable for ComparisonOperationKind {
    fn as_node(&self) -> Node {
        Node::ComparisonOperationKind(self)
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct LogicalOperationExpression {
    pub id: NodeId,
    pub span: Span,
    pub kind: LogicalOperationKind,
}

impl Nodeable for LogicalOperationExpression {
    fn as_node(&self) -> Node {
        Node::LogicalOperationExpression(self)
    }
}

impl Spanned for LogicalOperationExpression {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum LogicalOperationKind {
    And {
        left: Box<Expression>,
        double_ampersand: Span,
        right: Box<Expression>,
    },
    Or {
        left: Box<Expression>,
        double_pipe: Span,
        right: Box<Expression>,
    },
    Not {
        bang: Span,
        right: Box<Expression>,
    },
    LogicalAnd {
        left: Box<Expression>,
        and: Span,
        right: Box<Expression>,
    },
    LogicalOr {
        left: Box<Expression>,
        or: Span,
        right: Box<Expression>,
    },
    LogicalXor {
        left: Box<Expression>,
        xor: Span,
        right: Box<Expression>,
    },
}

impl Nodeable for LogicalOperationKind {
    fn as_node(&self) -> Node {
        Node::LogicalOperationKind(self)
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub struct Name {
    pub id: NodeId,
    pub kind: NameKind,
    pub span: Span,
}

impl Nodeable for Name {
    fn as_node(&self) -> Node {
        Node::Name(self)
    }
}

impl Spanned for Name {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum NameKind {
    Special(SpecialName),
    Unresolved(UnresolvedName),
    Resolved(ResolvedName),
}

impl Nodeable for NameKind {
    fn as_node(&self) -> Node {
        Node::NameKind(self)
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub struct SpecialName {
    pub id: NodeId,
    pub span: Span,
    pub kind: SpecialNameKind,
    pub symbol: Symbol,
}

impl Nodeable for SpecialName {
    fn as_node(&self) -> Node {
        Node::SpecialName(self)
    }
}

impl Spanned for SpecialName {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum SpecialNameKind {
    Self_(Span),
    Parent(Span),
    Static(Span),
}

impl Nodeable for SpecialNameKind {
    fn as_node(&self) -> Node {
        Node::SpecialNameKind(self)
    }
}

impl Spanned for SpecialNameKind {
    fn span(&self) -> Span {
        match self {
            SpecialNameKind::Self_(span) => *span,
            SpecialNameKind::Parent(span) => *span,
            SpecialNameKind::Static(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub struct UnresolvedName {
    pub id: NodeId,
    pub span: Span,
    pub symbol: Symbol,
    pub qualification: NameQualification,
}

impl Nodeable for UnresolvedName {
    fn as_node(&self) -> Node {
        Node::UnresolvedName(self)
    }
}

impl Spanned for UnresolvedName {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub struct ResolvedName {
    pub id: NodeId,
    pub span: Span,
    pub resolved: Symbol,
    pub original: Symbol,
}

impl Nodeable for ResolvedName {
    fn as_node(&self) -> Node {
        Node::ResolvedName(self)
    }
}

impl Spanned for ResolvedName {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct Property {
    pub id: NodeId,
    pub span: Span,
    pub attributes: Vec<AttributeGroup>,
    pub modifiers: PropertyModifierGroup,
    pub r#type: Option<DataType>,
    pub entries: Vec<PropertyEntry>,
    pub end: Span,
}

impl Nodeable for Property {
    fn as_node(&self) -> Node {
        Node::Property(self)
    }
}

impl Spanned for Property {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct VariableProperty {
    pub id: NodeId,
    pub span: Span,
    pub attributes: Vec<AttributeGroup>,
    pub r#type: Option<DataType>,
    pub entries: Vec<PropertyEntry>,
    pub end: Span,
}

impl Nodeable for VariableProperty {
    fn as_node(&self) -> Node {
        Node::VariableProperty(self)
    }
}

impl Spanned for VariableProperty {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct PropertyEntry {
    pub id: NodeId,
    pub span: Span,
    pub kind: PropertyEntryKind,
}

impl Nodeable for PropertyEntry {
    fn as_node(&self) -> Node {
        Node::PropertyEntry(self)
    }
}

impl Spanned for PropertyEntry {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum PropertyEntryKind {
    Uninitialized {
        variable: SimpleVariable,
    },
    Initialized {
        variable: SimpleVariable,
        equals: Span,
        value: Expression,
    },
}

impl Nodeable for PropertyEntryKind {
    fn as_node(&self) -> Node {
        Node::PropertyEntryKind(self)
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TraitBody {
    pub id: NodeId,
    pub span: Span,
    pub left_brace: Span,
    pub members: Vec<ClassishMember>,
    pub right_brace: Span,
}

impl Nodeable for TraitBody {
    fn as_node(&self) -> Node {
        Node::TraitBody(self)
    }
}

impl Spanned for TraitBody {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TraitStatement {
    pub id: NodeId,
    pub span: Span,
    pub r#trait: Span,
    pub name: Name,
    pub attributes: Vec<AttributeGroup>,
    pub body: TraitBody,
}

impl Nodeable for TraitStatement {
    fn as_node(&self) -> Node {
        Node::TraitStatement(self)
    }
}

impl Spanned for TraitStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TraitUsage {
    pub id: NodeId,
    pub span: Span,
    pub r#use: Span,
    pub traits: Vec<Name>,
    pub adaptations: Vec<TraitUsageAdaptation>,
}

impl Nodeable for TraitUsage {
    fn as_node(&self) -> Node {
        Node::TraitUsage(self)
    }
}

impl Spanned for TraitUsage {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TraitUsageAdaptation {
    pub id: NodeId,
    pub span: Span,
    pub kind: TraitUsageAdaptationKind,
}

impl Nodeable for TraitUsageAdaptation {
    fn as_node(&self) -> Node {
        Node::TraitUsageAdaptation(self)
    }
}

impl Spanned for TraitUsageAdaptation {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum TraitUsageAdaptationKind {
    Alias {
        r#trait: Option<Name>,
        method: SimpleIdentifier,
        alias: SimpleIdentifier,
        visibility: Option<VisibilityModifier>,
    },
    Visibility {
        r#trait: Option<Name>,
        method: SimpleIdentifier,
        visibility: VisibilityModifier,
    },
    Precedence {
        r#trait: Option<Name>,
        method: SimpleIdentifier,
        insteadof: Vec<SimpleIdentifier>,
    },
}

impl Nodeable for TraitUsageAdaptationKind {
    fn as_node(&self) -> Node {
        Node::TraitUsageAdaptationKind(self)
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct CatchType {
    pub id: NodeId,
    pub span: Span,
    pub kind: CatchTypeKind,
}

impl Nodeable for CatchType {
    fn as_node(&self) -> Node {
        Node::CatchType(self)
    }
}

impl Spanned for CatchType {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum CatchTypeKind {
    Identifier { identifier: SimpleIdentifier },
    Union { identifiers: Vec<SimpleIdentifier> },
}

impl Nodeable for CatchTypeKind {
    fn as_node(&self) -> Node {
        Node::CatchTypeKind(self)
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct TryStatement {
    pub id: NodeId,
    pub span: Span,
    pub start: Span,
    pub end: Span,
    pub body: Block,
    pub catches: Vec<CatchBlock>,
    pub finally: Option<FinallyBlock>,
}

impl Nodeable for TryStatement {
    fn as_node(&self) -> Node {
        Node::TryStatement(self)
    }
}

impl Spanned for TryStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct CatchBlock {
    pub id: NodeId,
    pub span: Span,
    pub start: Span,
    pub end: Span,
    pub types: CatchType,
    pub var: Option<SimpleVariable>,
    pub body: Block,
}

impl Nodeable for CatchBlock {
    fn as_node(&self) -> Node {
        Node::CatchBlock(self)
    }
}

impl Spanned for CatchBlock {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct FinallyBlock {
    pub id: NodeId,
    pub span: Span,
    pub start: Span,
    pub end: Span,
    pub body: Block,
}

impl Nodeable for FinallyBlock {
    fn as_node(&self) -> Node {
        Node::FinallyBlock(self)
    }
}

impl Spanned for FinallyBlock {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Variable {
    SimpleVariable(SimpleVariable),
    VariableVariable(VariableVariable),
    BracedVariableVariable(BracedVariableVariable),
}

impl Nodeable for Variable {
    fn as_node(&self) -> Node {
        Node::Variable(self)
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct SimpleVariable {
    pub id: NodeId,
    pub symbol: Symbol,
    pub stripped: Symbol,
    pub span: Span,
}

impl Nodeable for SimpleVariable {
    fn as_node(&self) -> Node {
        Node::SimpleVariable(self)
    }
}

impl Spanned for SimpleVariable {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct VariableVariable {
    pub id: NodeId,
    pub span: Span,
    pub variable: Box<Variable>,
}

impl Nodeable for VariableVariable {
    fn as_node(&self) -> Node {
        Node::VariableVariable(self)
    }
}

impl Spanned for VariableVariable {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct BracedVariableVariable {
    pub id: NodeId,
    pub span: Span,
    pub start: Span,
    pub variable: Box<Expression>,
    pub end: Span,
}

impl Nodeable for BracedVariableVariable {
    fn as_node(&self) -> Node {
        Node::BracedVariableVariable(self)
    }
}

impl Spanned for BracedVariableVariable {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub enum Ending {
    Missing(Span),
    Semicolon(Span),
    CloseTag(Span),
}

impl Nodeable for Ending {
    fn as_node(&self) -> Node {
        Node::Ending(self)
    }
}

impl Spanned for Ending {
    fn span(&self) -> Span {
        match self {
            Ending::Missing(span) => *span,
            Ending::Semicolon(span) => *span,
            Ending::CloseTag(span) => *span,
            _ => Span::default(),
        }
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct StaticStatement {
    pub id: NodeId,
    pub span: Span,
    pub vars: Vec<StaticVar>,
    pub semicolon: Span,
}

impl Nodeable for StaticStatement {
    fn as_node(&self) -> Node {
        Node::StaticStatement(self)
    }
}

impl Spanned for StaticStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct SwitchStatement {
    pub id: NodeId,
    pub span: Span,
    pub switch: Span,
    pub left_parenthesis: Span,
    pub condition: Expression,
    pub right_parenthesis: Span,
    pub cases: Vec<Case>,
}

impl Nodeable for SwitchStatement {
    fn as_node(&self) -> Node {
        Node::SwitchStatement(self)
    }
}

impl Spanned for SwitchStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct EchoStatement {
    pub id: NodeId,
    pub span: Span,
    pub echo: Span,
    pub values: Vec<Expression>,
    pub ending: Ending,
}

impl Nodeable for EchoStatement {
    fn as_node(&self) -> Node {
        Node::EchoStatement(self)
    }
}

impl Spanned for EchoStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct ReturnStatement {
    pub id: NodeId,
    pub span: Span,
    pub r#return: Span,
    pub value: Option<Expression>,
    pub ending: Ending,
}

impl Nodeable for ReturnStatement {
    fn as_node(&self) -> Node {
        Node::ReturnStatement(self)
    }
}

impl Spanned for ReturnStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct UseStatement {
    pub id: NodeId,
    pub span: Span,
    pub kind: UseKind,
    pub uses: Vec<Use>,
}

impl Nodeable for UseStatement {
    fn as_node(&self) -> Node {
        Node::UseStatement(self)
    }
}

impl Spanned for UseStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct GroupUseStatement {
    pub id: NodeId,
    pub span: Span,
    pub prefix: SimpleIdentifier,
    pub kind: UseKind,
    pub uses: Vec<Use>,
}

impl Nodeable for GroupUseStatement {
    fn as_node(&self) -> Node {
        Node::GroupUseStatement(self)
    }
}

impl Spanned for GroupUseStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct HaltCompilerStatement {
    pub id: NodeId,
    pub span: Span,
    pub content: Option<Token>,
}

impl Nodeable for HaltCompilerStatement {
    fn as_node(&self) -> Node {
        Node::HaltCompilerStatement(self)
    }
}

impl Spanned for HaltCompilerStatement {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct StaticVar {
    pub id: NodeId,
    pub span: Span,
    pub var: Variable,
    pub default: Option<Expression>,
}

impl Nodeable for StaticVar {
    fn as_node(&self) -> Node {
        Node::StaticVar(self)
    }
}

impl Spanned for StaticVar {
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Debug, PartialEq, Clone)]
pub enum Node<'a> {
    Block(&'a Block),
    Statement(&'a Statement),
    StatementKind(&'a StatementKind),
    Expression(&'a Expression),
    ExpressionKind(&'a ExpressionKind),
    InlineHtmlStatement(&'a InlineHtmlStatement),
    FullOpeningTagStatement(&'a FullOpeningTagStatement),
    ShortOpeningTagStatement(&'a ShortOpeningTagStatement),
    EchoOpeningTagStatement(&'a EchoOpeningTagStatement),
    ClosingTagStatement(&'a ClosingTagStatement),
    ExpressionStatement(&'a ExpressionStatement),
    GlobalStatement(&'a GlobalStatement),
    BlockStatement(&'a BlockStatement),
    CastKind(&'a CastKind),
    Case(&'a Case),
    Use(&'a Use),
    UseKind(&'a UseKind),
    EvalExpression(&'a EvalExpression),
    EmptyExpression(&'a EmptyExpression),
    DieExpression(&'a DieExpression),
    ExitExpression(&'a ExitExpression),
    IssetExpression(&'a IssetExpression),
    UnsetExpression(&'a UnsetExpression),
    PrintExpression(&'a PrintExpression),
    ConcatExpression(&'a ConcatExpression),
    InstanceofExpression(&'a InstanceofExpression),
    ReferenceExpression(&'a ReferenceExpression),
    ParenthesizedExpression(&'a ParenthesizedExpression),
    ErrorSuppressExpression(&'a ErrorSuppressExpression),
    IncludeExpression(&'a IncludeExpression),
    IncludeOnceExpression(&'a IncludeOnceExpression),
    RequireExpression(&'a RequireExpression),
    RequireOnceExpression(&'a RequireOnceExpression),
    FunctionCallExpression(&'a FunctionCallExpression),
    FunctionClosureCreationExpression(&'a FunctionClosureCreationExpression),
    MethodCallExpression(&'a MethodCallExpression),
    MethodClosureCreationExpression(&'a MethodClosureCreationExpression),
    NullsafeMethodCallExpression(&'a NullsafeMethodCallExpression),
    StaticMethodCallExpression(&'a StaticMethodCallExpression),
    StaticVariableMethodCallExpression(&'a StaticVariableMethodCallExpression),
    StaticMethodClosureCreationExpression(&'a StaticMethodClosureCreationExpression),
    StaticVariableMethodClosureCreationExpression(
        &'a StaticVariableMethodClosureCreationExpression,
    ),
    PropertyFetchExpression(&'a PropertyFetchExpression),
    NullsafePropertyFetchExpression(&'a NullsafePropertyFetchExpression),
    StaticPropertyFetchExpression(&'a StaticPropertyFetchExpression),
    ConstantFetchExpression(&'a ConstantFetchExpression),
    ShortArrayExpression(&'a ShortArrayExpression),
    ArrayExpression(&'a ArrayExpression),
    ListExpression(&'a ListExpression),
    NewExpression(&'a NewExpression),
    InterpolatedStringExpression(&'a InterpolatedStringExpression),
    HeredocExpression(&'a HeredocExpression),
    NowdocExpression(&'a NowdocExpression),
    ShellExecExpression(&'a ShellExecExpression),
    BoolExpression(&'a BoolExpression),
    ArrayIndexExpression(&'a ArrayIndexExpression),
    ShortTernaryExpression(&'a ShortTernaryExpression),
    TernaryExpression(&'a TernaryExpression),
    CoalesceExpression(&'a CoalesceExpression),
    CloneExpression(&'a CloneExpression),
    MatchExpression(&'a MatchExpression),
    ThrowExpression(&'a ThrowExpression),
    YieldExpression(&'a YieldExpression),
    YieldFromExpression(&'a YieldFromExpression),
    CastExpression(&'a CastExpression),
    DefaultMatchArm(&'a DefaultMatchArm),
    MatchArm(&'a MatchArm),
    MagicConstantExpression(&'a MagicConstantExpression),
    StringPart(&'a StringPart),
    LiteralStringPart(&'a LiteralStringPart),
    ExpressionStringPart(&'a ExpressionStringPart),
    ArrayItem(&'a ArrayItem),
    ArrayItemValue(&'a ArrayItemValue),
    ArrayItemReferencedValue(&'a ArrayItemReferencedValue),
    ArrayItemSpreadValue(&'a ArrayItemSpreadValue),
    ArrayItemKeyValue(&'a ArrayItemKeyValue),
    ArrayItemReferencedKeyValue(&'a ArrayItemReferencedKeyValue),
    ListEntry(&'a ListEntry),
    ListEntryValue(&'a ListEntryValue),
    ListEntryKeyValue(&'a ListEntryKeyValue),
    PositionalArgument(&'a PositionalArgument),
    NamedArgument(&'a NamedArgument),
    Argument(&'a Argument),
    ArgumentList(&'a ArgumentList),
    SingleArgument(&'a SingleArgument),
    ArgumentPlaceholder(&'a ArgumentPlaceholder),
    Attribute(&'a Attribute),
    AttributeGroup(&'a AttributeGroup),
    ClassBody(&'a ClassBody),
    ClassStatement(&'a ClassStatement),
    AnonymousClassBody(&'a AnonymousClassBody),
    AnonymousClassExpression(&'a AnonymousClassExpression),
    ClassExtends(&'a ClassExtends),
    ClassImplements(&'a ClassImplements),
    ClassishMember(&'a ClassishMember),
    ConstantEntry(&'a ConstantEntry),
    ClassishConstantEntry(&'a ClassishConstantEntry),
    ConstantStatement(&'a ConstantStatement),
    ClassishConstant(&'a ClassishConstant),
    IfStatement(&'a IfStatement),
    IfStatementBody(&'a IfStatementBody),
    IfStatementElseIf(&'a IfStatementElseIf),
    IfStatementElse(&'a IfStatementElse),
    IfStatementElseIfBlock(&'a IfStatementElseIfBlock),
    IfStatementElseBlock(&'a IfStatementElseBlock),
    DataType(&'a DataType),
    DeclareEntry(&'a DeclareEntry),
    DeclareEntryGroup(&'a DeclareEntryGroup),
    DeclareBody(&'a DeclareBody),
    DeclareStatement(&'a DeclareStatement),
    UnitEnumCase(&'a UnitEnumCase),
    UnitEnumMember(&'a UnitEnumMember),
    UnitEnumBody(&'a UnitEnumBody),
    UnitEnumStatement(&'a UnitEnumStatement),
    BackedEnumCase(&'a BackedEnumCase),
    BackedEnumMember(&'a BackedEnumMember),
    BackedEnumBody(&'a BackedEnumBody),
    BackedEnumStatement(&'a BackedEnumStatement),
    ReturnType(&'a ReturnType),
    FunctionParameter(&'a FunctionParameter),
    FunctionParameterList(&'a FunctionParameterList),
    FunctionBody(&'a FunctionBody),
    FunctionStatement(&'a FunctionStatement),
    ClosureUseVariable(&'a ClosureUseVariable),
    ClosureUse(&'a ClosureUse),
    ClosureExpression(&'a ClosureExpression),
    ArrowFunctionExpression(&'a ArrowFunctionExpression),
    ConstructorParameter(&'a ConstructorParameter),
    ConstructorParameterList(&'a ConstructorParameterList),
    AbstractConstructor(&'a AbstractConstructor),
    ConcreteConstructor(&'a ConcreteConstructor),
    AbstractMethod(&'a AbstractMethod),
    ConcreteMethod(&'a ConcreteMethod),
    MethodBody(&'a MethodBody),
    LabelStatement(&'a LabelStatement),
    GotoStatement(&'a GotoStatement),
    Identifier(&'a Identifier),
    SimpleIdentifier(&'a SimpleIdentifier),
    DynamicIdentifier(&'a DynamicIdentifier),
    InterfaceExtends(&'a InterfaceExtends),
    InterfaceBody(&'a InterfaceBody),
    InterfaceStatement(&'a InterfaceStatement),
    Literal(&'a Literal),
    LiteralKind(&'a LiteralKind),
    ForeachStatement(&'a ForeachStatement),
    ForeachStatementIterator(&'a ForeachStatementIterator),
    ForeachStatementBody(&'a ForeachStatementBody),
    ForStatement(&'a ForStatement),
    ForStatementIterator(&'a ForStatementIterator),
    ForStatementBody(&'a ForStatementBody),
    DoWhileStatement(&'a DoWhileStatement),
    WhileStatement(&'a WhileStatement),
    WhileStatementBody(&'a WhileStatementBody),
    Level(&'a Level),
    BreakStatement(&'a BreakStatement),
    ContinueStatement(&'a ContinueStatement),
    VisibilityModifier(&'a VisibilityModifier),
    PromotedPropertyModifier(&'a PromotedPropertyModifier),
    PromotedPropertyModifierGroup(&'a PromotedPropertyModifierGroup),
    PropertyModifier(&'a PropertyModifier),
    PropertyModifierGroup(&'a PropertyModifierGroup),
    MethodModifier(&'a MethodModifier),
    MethodModifierGroup(&'a MethodModifierGroup),
    ClassModifier(&'a ClassModifier),
    ClassModifierGroup(&'a ClassModifierGroup),
    ConstantModifier(&'a ConstantModifier),
    ConstantModifierGroup(&'a ConstantModifierGroup),
    UnbracedNamespace(&'a UnbracedNamespace),
    BracedNamespace(&'a BracedNamespace),
    BracedNamespaceBody(&'a BracedNamespaceBody),
    NamespaceStatement(&'a NamespaceStatement),
    ArithmeticOperationExpression(&'a ArithmeticOperationExpression),
    ArithmeticOperationKind(&'a ArithmeticOperationKind),
    AssignmentOperationExpression(&'a AssignmentOperationExpression),
    AssignmentOperationKind(&'a AssignmentOperationKind),
    BitwiseOperationExpression(&'a BitwiseOperationExpression),
    BitwiseOperationKind(&'a BitwiseOperationKind),
    ComparisonOperationExpression(&'a ComparisonOperationExpression),
    ComparisonOperationKind(&'a ComparisonOperationKind),
    LogicalOperationExpression(&'a LogicalOperationExpression),
    LogicalOperationKind(&'a LogicalOperationKind),
    Name(&'a Name),
    NameKind(&'a NameKind),
    SpecialName(&'a SpecialName),
    SpecialNameKind(&'a SpecialNameKind),
    UnresolvedName(&'a UnresolvedName),
    ResolvedName(&'a ResolvedName),
    Property(&'a Property),
    VariableProperty(&'a VariableProperty),
    PropertyEntry(&'a PropertyEntry),
    PropertyEntryKind(&'a PropertyEntryKind),
    TraitBody(&'a TraitBody),
    TraitStatement(&'a TraitStatement),
    TraitUsage(&'a TraitUsage),
    TraitUsageAdaptation(&'a TraitUsageAdaptation),
    TraitUsageAdaptationKind(&'a TraitUsageAdaptationKind),
    CatchType(&'a CatchType),
    CatchTypeKind(&'a CatchTypeKind),
    TryStatement(&'a TryStatement),
    CatchBlock(&'a CatchBlock),
    FinallyBlock(&'a FinallyBlock),
    Variable(&'a Variable),
    SimpleVariable(&'a SimpleVariable),
    VariableVariable(&'a VariableVariable),
    BracedVariableVariable(&'a BracedVariableVariable),
    Ending(&'a Ending),
    StaticStatement(&'a StaticStatement),
    SwitchStatement(&'a SwitchStatement),
    EchoStatement(&'a EchoStatement),
    ReturnStatement(&'a ReturnStatement),
    UseStatement(&'a UseStatement),
    GroupUseStatement(&'a GroupUseStatement),
    HaltCompilerStatement(&'a HaltCompilerStatement),
    StaticVar(&'a StaticVar),
}

impl<'a> Node<'a> {
    pub fn as_block(self) -> Option<&'a Block> {
        match self {
            Node::Block(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_block(&self) -> bool {
        matches!(self, Node::Block(_))
    }

    pub fn as_statement(self) -> Option<&'a Statement> {
        match self {
            Node::Statement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_statement(&self) -> bool {
        matches!(self, Node::Statement(_))
    }

    pub fn as_statement_kind(self) -> Option<&'a StatementKind> {
        match self {
            Node::StatementKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_statement_kind(&self) -> bool {
        matches!(self, Node::StatementKind(_))
    }

    pub fn as_expression(self) -> Option<&'a Expression> {
        match self {
            Node::Expression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_expression(&self) -> bool {
        matches!(self, Node::Expression(_))
    }

    pub fn as_expression_kind(self) -> Option<&'a ExpressionKind> {
        match self {
            Node::ExpressionKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_expression_kind(&self) -> bool {
        matches!(self, Node::ExpressionKind(_))
    }

    pub fn as_inline_html_statement(self) -> Option<&'a InlineHtmlStatement> {
        match self {
            Node::InlineHtmlStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_inline_html_statement(&self) -> bool {
        matches!(self, Node::InlineHtmlStatement(_))
    }

    pub fn as_full_opening_tag_statement(self) -> Option<&'a FullOpeningTagStatement> {
        match self {
            Node::FullOpeningTagStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_full_opening_tag_statement(&self) -> bool {
        matches!(self, Node::FullOpeningTagStatement(_))
    }

    pub fn as_short_opening_tag_statement(self) -> Option<&'a ShortOpeningTagStatement> {
        match self {
            Node::ShortOpeningTagStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_short_opening_tag_statement(&self) -> bool {
        matches!(self, Node::ShortOpeningTagStatement(_))
    }

    pub fn as_echo_opening_tag_statement(self) -> Option<&'a EchoOpeningTagStatement> {
        match self {
            Node::EchoOpeningTagStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_echo_opening_tag_statement(&self) -> bool {
        matches!(self, Node::EchoOpeningTagStatement(_))
    }

    pub fn as_closing_tag_statement(self) -> Option<&'a ClosingTagStatement> {
        match self {
            Node::ClosingTagStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_closing_tag_statement(&self) -> bool {
        matches!(self, Node::ClosingTagStatement(_))
    }

    pub fn as_expression_statement(self) -> Option<&'a ExpressionStatement> {
        match self {
            Node::ExpressionStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_expression_statement(&self) -> bool {
        matches!(self, Node::ExpressionStatement(_))
    }

    pub fn as_global_statement(self) -> Option<&'a GlobalStatement> {
        match self {
            Node::GlobalStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_global_statement(&self) -> bool {
        matches!(self, Node::GlobalStatement(_))
    }

    pub fn as_block_statement(self) -> Option<&'a BlockStatement> {
        match self {
            Node::BlockStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_block_statement(&self) -> bool {
        matches!(self, Node::BlockStatement(_))
    }

    pub fn as_cast_kind(self) -> Option<&'a CastKind> {
        match self {
            Node::CastKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_cast_kind(&self) -> bool {
        matches!(self, Node::CastKind(_))
    }

    pub fn as_case(self) -> Option<&'a Case> {
        match self {
            Node::Case(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_case(&self) -> bool {
        matches!(self, Node::Case(_))
    }

    pub fn as_use(self) -> Option<&'a Use> {
        match self {
            Node::Use(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_use(&self) -> bool {
        matches!(self, Node::Use(_))
    }

    pub fn as_use_kind(self) -> Option<&'a UseKind> {
        match self {
            Node::UseKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_use_kind(&self) -> bool {
        matches!(self, Node::UseKind(_))
    }

    pub fn as_eval_expression(self) -> Option<&'a EvalExpression> {
        match self {
            Node::EvalExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_eval_expression(&self) -> bool {
        matches!(self, Node::EvalExpression(_))
    }

    pub fn as_empty_expression(self) -> Option<&'a EmptyExpression> {
        match self {
            Node::EmptyExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_empty_expression(&self) -> bool {
        matches!(self, Node::EmptyExpression(_))
    }

    pub fn as_die_expression(self) -> Option<&'a DieExpression> {
        match self {
            Node::DieExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_die_expression(&self) -> bool {
        matches!(self, Node::DieExpression(_))
    }

    pub fn as_exit_expression(self) -> Option<&'a ExitExpression> {
        match self {
            Node::ExitExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_exit_expression(&self) -> bool {
        matches!(self, Node::ExitExpression(_))
    }

    pub fn as_isset_expression(self) -> Option<&'a IssetExpression> {
        match self {
            Node::IssetExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_isset_expression(&self) -> bool {
        matches!(self, Node::IssetExpression(_))
    }

    pub fn as_unset_expression(self) -> Option<&'a UnsetExpression> {
        match self {
            Node::UnsetExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_unset_expression(&self) -> bool {
        matches!(self, Node::UnsetExpression(_))
    }

    pub fn as_print_expression(self) -> Option<&'a PrintExpression> {
        match self {
            Node::PrintExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_print_expression(&self) -> bool {
        matches!(self, Node::PrintExpression(_))
    }

    pub fn as_concat_expression(self) -> Option<&'a ConcatExpression> {
        match self {
            Node::ConcatExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_concat_expression(&self) -> bool {
        matches!(self, Node::ConcatExpression(_))
    }

    pub fn as_instanceof_expression(self) -> Option<&'a InstanceofExpression> {
        match self {
            Node::InstanceofExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_instanceof_expression(&self) -> bool {
        matches!(self, Node::InstanceofExpression(_))
    }

    pub fn as_reference_expression(self) -> Option<&'a ReferenceExpression> {
        match self {
            Node::ReferenceExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_reference_expression(&self) -> bool {
        matches!(self, Node::ReferenceExpression(_))
    }

    pub fn as_parenthesized_expression(self) -> Option<&'a ParenthesizedExpression> {
        match self {
            Node::ParenthesizedExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_parenthesized_expression(&self) -> bool {
        matches!(self, Node::ParenthesizedExpression(_))
    }

    pub fn as_error_suppress_expression(self) -> Option<&'a ErrorSuppressExpression> {
        match self {
            Node::ErrorSuppressExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_error_suppress_expression(&self) -> bool {
        matches!(self, Node::ErrorSuppressExpression(_))
    }

    pub fn as_include_expression(self) -> Option<&'a IncludeExpression> {
        match self {
            Node::IncludeExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_include_expression(&self) -> bool {
        matches!(self, Node::IncludeExpression(_))
    }

    pub fn as_include_once_expression(self) -> Option<&'a IncludeOnceExpression> {
        match self {
            Node::IncludeOnceExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_include_once_expression(&self) -> bool {
        matches!(self, Node::IncludeOnceExpression(_))
    }

    pub fn as_require_expression(self) -> Option<&'a RequireExpression> {
        match self {
            Node::RequireExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_require_expression(&self) -> bool {
        matches!(self, Node::RequireExpression(_))
    }

    pub fn as_require_once_expression(self) -> Option<&'a RequireOnceExpression> {
        match self {
            Node::RequireOnceExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_require_once_expression(&self) -> bool {
        matches!(self, Node::RequireOnceExpression(_))
    }

    pub fn as_function_call_expression(self) -> Option<&'a FunctionCallExpression> {
        match self {
            Node::FunctionCallExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_function_call_expression(&self) -> bool {
        matches!(self, Node::FunctionCallExpression(_))
    }

    pub fn as_function_closure_creation_expression(
        self,
    ) -> Option<&'a FunctionClosureCreationExpression> {
        match self {
            Node::FunctionClosureCreationExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_function_closure_creation_expression(&self) -> bool {
        matches!(self, Node::FunctionClosureCreationExpression(_))
    }

    pub fn as_method_call_expression(self) -> Option<&'a MethodCallExpression> {
        match self {
            Node::MethodCallExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_method_call_expression(&self) -> bool {
        matches!(self, Node::MethodCallExpression(_))
    }

    pub fn as_method_closure_creation_expression(
        self,
    ) -> Option<&'a MethodClosureCreationExpression> {
        match self {
            Node::MethodClosureCreationExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_method_closure_creation_expression(&self) -> bool {
        matches!(self, Node::MethodClosureCreationExpression(_))
    }

    pub fn as_nullsafe_method_call_expression(self) -> Option<&'a NullsafeMethodCallExpression> {
        match self {
            Node::NullsafeMethodCallExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_nullsafe_method_call_expression(&self) -> bool {
        matches!(self, Node::NullsafeMethodCallExpression(_))
    }

    pub fn as_static_method_call_expression(self) -> Option<&'a StaticMethodCallExpression> {
        match self {
            Node::StaticMethodCallExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_static_method_call_expression(&self) -> bool {
        matches!(self, Node::StaticMethodCallExpression(_))
    }

    pub fn as_static_variable_method_call_expression(
        self,
    ) -> Option<&'a StaticVariableMethodCallExpression> {
        match self {
            Node::StaticVariableMethodCallExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_static_variable_method_call_expression(&self) -> bool {
        matches!(self, Node::StaticVariableMethodCallExpression(_))
    }

    pub fn as_static_method_closure_creation_expression(
        self,
    ) -> Option<&'a StaticMethodClosureCreationExpression> {
        match self {
            Node::StaticMethodClosureCreationExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_static_method_closure_creation_expression(&self) -> bool {
        matches!(self, Node::StaticMethodClosureCreationExpression(_))
    }

    pub fn as_static_variable_method_closure_creation_expression(
        self,
    ) -> Option<&'a StaticVariableMethodClosureCreationExpression> {
        match self {
            Node::StaticVariableMethodClosureCreationExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_static_variable_method_closure_creation_expression(&self) -> bool {
        matches!(self, Node::StaticVariableMethodClosureCreationExpression(_))
    }

    pub fn as_property_fetch_expression(self) -> Option<&'a PropertyFetchExpression> {
        match self {
            Node::PropertyFetchExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_property_fetch_expression(&self) -> bool {
        matches!(self, Node::PropertyFetchExpression(_))
    }

    pub fn as_nullsafe_property_fetch_expression(
        self,
    ) -> Option<&'a NullsafePropertyFetchExpression> {
        match self {
            Node::NullsafePropertyFetchExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_nullsafe_property_fetch_expression(&self) -> bool {
        matches!(self, Node::NullsafePropertyFetchExpression(_))
    }

    pub fn as_static_property_fetch_expression(self) -> Option<&'a StaticPropertyFetchExpression> {
        match self {
            Node::StaticPropertyFetchExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_static_property_fetch_expression(&self) -> bool {
        matches!(self, Node::StaticPropertyFetchExpression(_))
    }

    pub fn as_constant_fetch_expression(self) -> Option<&'a ConstantFetchExpression> {
        match self {
            Node::ConstantFetchExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_constant_fetch_expression(&self) -> bool {
        matches!(self, Node::ConstantFetchExpression(_))
    }

    pub fn as_short_array_expression(self) -> Option<&'a ShortArrayExpression> {
        match self {
            Node::ShortArrayExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_short_array_expression(&self) -> bool {
        matches!(self, Node::ShortArrayExpression(_))
    }

    pub fn as_array_expression(self) -> Option<&'a ArrayExpression> {
        match self {
            Node::ArrayExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_array_expression(&self) -> bool {
        matches!(self, Node::ArrayExpression(_))
    }

    pub fn as_list_expression(self) -> Option<&'a ListExpression> {
        match self {
            Node::ListExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_list_expression(&self) -> bool {
        matches!(self, Node::ListExpression(_))
    }

    pub fn as_new_expression(self) -> Option<&'a NewExpression> {
        match self {
            Node::NewExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_new_expression(&self) -> bool {
        matches!(self, Node::NewExpression(_))
    }

    pub fn as_interpolated_string_expression(self) -> Option<&'a InterpolatedStringExpression> {
        match self {
            Node::InterpolatedStringExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_interpolated_string_expression(&self) -> bool {
        matches!(self, Node::InterpolatedStringExpression(_))
    }

    pub fn as_heredoc_expression(self) -> Option<&'a HeredocExpression> {
        match self {
            Node::HeredocExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_heredoc_expression(&self) -> bool {
        matches!(self, Node::HeredocExpression(_))
    }

    pub fn as_nowdoc_expression(self) -> Option<&'a NowdocExpression> {
        match self {
            Node::NowdocExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_nowdoc_expression(&self) -> bool {
        matches!(self, Node::NowdocExpression(_))
    }

    pub fn as_shell_exec_expression(self) -> Option<&'a ShellExecExpression> {
        match self {
            Node::ShellExecExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_shell_exec_expression(&self) -> bool {
        matches!(self, Node::ShellExecExpression(_))
    }

    pub fn as_bool_expression(self) -> Option<&'a BoolExpression> {
        match self {
            Node::BoolExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_bool_expression(&self) -> bool {
        matches!(self, Node::BoolExpression(_))
    }

    pub fn as_array_index_expression(self) -> Option<&'a ArrayIndexExpression> {
        match self {
            Node::ArrayIndexExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_array_index_expression(&self) -> bool {
        matches!(self, Node::ArrayIndexExpression(_))
    }

    pub fn as_short_ternary_expression(self) -> Option<&'a ShortTernaryExpression> {
        match self {
            Node::ShortTernaryExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_short_ternary_expression(&self) -> bool {
        matches!(self, Node::ShortTernaryExpression(_))
    }

    pub fn as_ternary_expression(self) -> Option<&'a TernaryExpression> {
        match self {
            Node::TernaryExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_ternary_expression(&self) -> bool {
        matches!(self, Node::TernaryExpression(_))
    }

    pub fn as_coalesce_expression(self) -> Option<&'a CoalesceExpression> {
        match self {
            Node::CoalesceExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_coalesce_expression(&self) -> bool {
        matches!(self, Node::CoalesceExpression(_))
    }

    pub fn as_clone_expression(self) -> Option<&'a CloneExpression> {
        match self {
            Node::CloneExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_clone_expression(&self) -> bool {
        matches!(self, Node::CloneExpression(_))
    }

    pub fn as_match_expression(self) -> Option<&'a MatchExpression> {
        match self {
            Node::MatchExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_match_expression(&self) -> bool {
        matches!(self, Node::MatchExpression(_))
    }

    pub fn as_throw_expression(self) -> Option<&'a ThrowExpression> {
        match self {
            Node::ThrowExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_throw_expression(&self) -> bool {
        matches!(self, Node::ThrowExpression(_))
    }

    pub fn as_yield_expression(self) -> Option<&'a YieldExpression> {
        match self {
            Node::YieldExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_yield_expression(&self) -> bool {
        matches!(self, Node::YieldExpression(_))
    }

    pub fn as_yield_from_expression(self) -> Option<&'a YieldFromExpression> {
        match self {
            Node::YieldFromExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_yield_from_expression(&self) -> bool {
        matches!(self, Node::YieldFromExpression(_))
    }

    pub fn as_cast_expression(self) -> Option<&'a CastExpression> {
        match self {
            Node::CastExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_cast_expression(&self) -> bool {
        matches!(self, Node::CastExpression(_))
    }

    pub fn as_default_match_arm(self) -> Option<&'a DefaultMatchArm> {
        match self {
            Node::DefaultMatchArm(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_default_match_arm(&self) -> bool {
        matches!(self, Node::DefaultMatchArm(_))
    }

    pub fn as_match_arm(self) -> Option<&'a MatchArm> {
        match self {
            Node::MatchArm(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_match_arm(&self) -> bool {
        matches!(self, Node::MatchArm(_))
    }

    pub fn as_magic_constant_expression(self) -> Option<&'a MagicConstantExpression> {
        match self {
            Node::MagicConstantExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_magic_constant_expression(&self) -> bool {
        matches!(self, Node::MagicConstantExpression(_))
    }

    pub fn as_string_part(self) -> Option<&'a StringPart> {
        match self {
            Node::StringPart(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_string_part(&self) -> bool {
        matches!(self, Node::StringPart(_))
    }

    pub fn as_literal_string_part(self) -> Option<&'a LiteralStringPart> {
        match self {
            Node::LiteralStringPart(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_literal_string_part(&self) -> bool {
        matches!(self, Node::LiteralStringPart(_))
    }

    pub fn as_expression_string_part(self) -> Option<&'a ExpressionStringPart> {
        match self {
            Node::ExpressionStringPart(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_expression_string_part(&self) -> bool {
        matches!(self, Node::ExpressionStringPart(_))
    }

    pub fn as_array_item(self) -> Option<&'a ArrayItem> {
        match self {
            Node::ArrayItem(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_array_item(&self) -> bool {
        matches!(self, Node::ArrayItem(_))
    }

    pub fn as_array_item_value(self) -> Option<&'a ArrayItemValue> {
        match self {
            Node::ArrayItemValue(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_array_item_value(&self) -> bool {
        matches!(self, Node::ArrayItemValue(_))
    }

    pub fn as_array_item_referenced_value(self) -> Option<&'a ArrayItemReferencedValue> {
        match self {
            Node::ArrayItemReferencedValue(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_array_item_referenced_value(&self) -> bool {
        matches!(self, Node::ArrayItemReferencedValue(_))
    }

    pub fn as_array_item_spread_value(self) -> Option<&'a ArrayItemSpreadValue> {
        match self {
            Node::ArrayItemSpreadValue(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_array_item_spread_value(&self) -> bool {
        matches!(self, Node::ArrayItemSpreadValue(_))
    }

    pub fn as_array_item_key_value(self) -> Option<&'a ArrayItemKeyValue> {
        match self {
            Node::ArrayItemKeyValue(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_array_item_key_value(&self) -> bool {
        matches!(self, Node::ArrayItemKeyValue(_))
    }

    pub fn as_array_item_referenced_key_value(self) -> Option<&'a ArrayItemReferencedKeyValue> {
        match self {
            Node::ArrayItemReferencedKeyValue(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_array_item_referenced_key_value(&self) -> bool {
        matches!(self, Node::ArrayItemReferencedKeyValue(_))
    }

    pub fn as_list_entry(self) -> Option<&'a ListEntry> {
        match self {
            Node::ListEntry(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_list_entry(&self) -> bool {
        matches!(self, Node::ListEntry(_))
    }

    pub fn as_list_entry_value(self) -> Option<&'a ListEntryValue> {
        match self {
            Node::ListEntryValue(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_list_entry_value(&self) -> bool {
        matches!(self, Node::ListEntryValue(_))
    }

    pub fn as_list_entry_key_value(self) -> Option<&'a ListEntryKeyValue> {
        match self {
            Node::ListEntryKeyValue(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_list_entry_key_value(&self) -> bool {
        matches!(self, Node::ListEntryKeyValue(_))
    }

    pub fn as_positional_argument(self) -> Option<&'a PositionalArgument> {
        match self {
            Node::PositionalArgument(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_positional_argument(&self) -> bool {
        matches!(self, Node::PositionalArgument(_))
    }

    pub fn as_named_argument(self) -> Option<&'a NamedArgument> {
        match self {
            Node::NamedArgument(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_named_argument(&self) -> bool {
        matches!(self, Node::NamedArgument(_))
    }

    pub fn as_argument(self) -> Option<&'a Argument> {
        match self {
            Node::Argument(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_argument(&self) -> bool {
        matches!(self, Node::Argument(_))
    }

    pub fn as_argument_list(self) -> Option<&'a ArgumentList> {
        match self {
            Node::ArgumentList(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_argument_list(&self) -> bool {
        matches!(self, Node::ArgumentList(_))
    }

    pub fn as_single_argument(self) -> Option<&'a SingleArgument> {
        match self {
            Node::SingleArgument(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_single_argument(&self) -> bool {
        matches!(self, Node::SingleArgument(_))
    }

    pub fn as_argument_placeholder(self) -> Option<&'a ArgumentPlaceholder> {
        match self {
            Node::ArgumentPlaceholder(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_argument_placeholder(&self) -> bool {
        matches!(self, Node::ArgumentPlaceholder(_))
    }

    pub fn as_attribute(self) -> Option<&'a Attribute> {
        match self {
            Node::Attribute(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_attribute(&self) -> bool {
        matches!(self, Node::Attribute(_))
    }

    pub fn as_attribute_group(self) -> Option<&'a AttributeGroup> {
        match self {
            Node::AttributeGroup(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_attribute_group(&self) -> bool {
        matches!(self, Node::AttributeGroup(_))
    }

    pub fn as_class_body(self) -> Option<&'a ClassBody> {
        match self {
            Node::ClassBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_class_body(&self) -> bool {
        matches!(self, Node::ClassBody(_))
    }

    pub fn as_class_statement(self) -> Option<&'a ClassStatement> {
        match self {
            Node::ClassStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_class_statement(&self) -> bool {
        matches!(self, Node::ClassStatement(_))
    }

    pub fn as_anonymous_class_body(self) -> Option<&'a AnonymousClassBody> {
        match self {
            Node::AnonymousClassBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_anonymous_class_body(&self) -> bool {
        matches!(self, Node::AnonymousClassBody(_))
    }

    pub fn as_anonymous_class_expression(self) -> Option<&'a AnonymousClassExpression> {
        match self {
            Node::AnonymousClassExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_anonymous_class_expression(&self) -> bool {
        matches!(self, Node::AnonymousClassExpression(_))
    }

    pub fn as_class_extends(self) -> Option<&'a ClassExtends> {
        match self {
            Node::ClassExtends(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_class_extends(&self) -> bool {
        matches!(self, Node::ClassExtends(_))
    }

    pub fn as_class_implements(self) -> Option<&'a ClassImplements> {
        match self {
            Node::ClassImplements(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_class_implements(&self) -> bool {
        matches!(self, Node::ClassImplements(_))
    }

    pub fn as_classish_member(self) -> Option<&'a ClassishMember> {
        match self {
            Node::ClassishMember(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_classish_member(&self) -> bool {
        matches!(self, Node::ClassishMember(_))
    }

    pub fn as_constant_entry(self) -> Option<&'a ConstantEntry> {
        match self {
            Node::ConstantEntry(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_constant_entry(&self) -> bool {
        matches!(self, Node::ConstantEntry(_))
    }

    pub fn as_classish_constant_entry(self) -> Option<&'a ClassishConstantEntry> {
        match self {
            Node::ClassishConstantEntry(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_classish_constant_entry(&self) -> bool {
        matches!(self, Node::ClassishConstantEntry(_))
    }

    pub fn as_constant_statement(self) -> Option<&'a ConstantStatement> {
        match self {
            Node::ConstantStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_constant_statement(&self) -> bool {
        matches!(self, Node::ConstantStatement(_))
    }

    pub fn as_classish_constant(self) -> Option<&'a ClassishConstant> {
        match self {
            Node::ClassishConstant(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_classish_constant(&self) -> bool {
        matches!(self, Node::ClassishConstant(_))
    }

    pub fn as_if_statement(self) -> Option<&'a IfStatement> {
        match self {
            Node::IfStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_if_statement(&self) -> bool {
        matches!(self, Node::IfStatement(_))
    }

    pub fn as_if_statement_body(self) -> Option<&'a IfStatementBody> {
        match self {
            Node::IfStatementBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_if_statement_body(&self) -> bool {
        matches!(self, Node::IfStatementBody(_))
    }

    pub fn as_if_statement_else_if(self) -> Option<&'a IfStatementElseIf> {
        match self {
            Node::IfStatementElseIf(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_if_statement_else_if(&self) -> bool {
        matches!(self, Node::IfStatementElseIf(_))
    }

    pub fn as_if_statement_else(self) -> Option<&'a IfStatementElse> {
        match self {
            Node::IfStatementElse(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_if_statement_else(&self) -> bool {
        matches!(self, Node::IfStatementElse(_))
    }

    pub fn as_if_statement_else_if_block(self) -> Option<&'a IfStatementElseIfBlock> {
        match self {
            Node::IfStatementElseIfBlock(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_if_statement_else_if_block(&self) -> bool {
        matches!(self, Node::IfStatementElseIfBlock(_))
    }

    pub fn as_if_statement_else_block(self) -> Option<&'a IfStatementElseBlock> {
        match self {
            Node::IfStatementElseBlock(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_if_statement_else_block(&self) -> bool {
        matches!(self, Node::IfStatementElseBlock(_))
    }

    pub fn as_data_type(self) -> Option<&'a DataType> {
        match self {
            Node::DataType(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_data_type(&self) -> bool {
        matches!(self, Node::DataType(_))
    }

    pub fn as_declare_entry(self) -> Option<&'a DeclareEntry> {
        match self {
            Node::DeclareEntry(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_declare_entry(&self) -> bool {
        matches!(self, Node::DeclareEntry(_))
    }

    pub fn as_declare_entry_group(self) -> Option<&'a DeclareEntryGroup> {
        match self {
            Node::DeclareEntryGroup(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_declare_entry_group(&self) -> bool {
        matches!(self, Node::DeclareEntryGroup(_))
    }

    pub fn as_declare_body(self) -> Option<&'a DeclareBody> {
        match self {
            Node::DeclareBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_declare_body(&self) -> bool {
        matches!(self, Node::DeclareBody(_))
    }

    pub fn as_declare_statement(self) -> Option<&'a DeclareStatement> {
        match self {
            Node::DeclareStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_declare_statement(&self) -> bool {
        matches!(self, Node::DeclareStatement(_))
    }

    pub fn as_unit_enum_case(self) -> Option<&'a UnitEnumCase> {
        match self {
            Node::UnitEnumCase(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_unit_enum_case(&self) -> bool {
        matches!(self, Node::UnitEnumCase(_))
    }

    pub fn as_unit_enum_member(self) -> Option<&'a UnitEnumMember> {
        match self {
            Node::UnitEnumMember(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_unit_enum_member(&self) -> bool {
        matches!(self, Node::UnitEnumMember(_))
    }

    pub fn as_unit_enum_body(self) -> Option<&'a UnitEnumBody> {
        match self {
            Node::UnitEnumBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_unit_enum_body(&self) -> bool {
        matches!(self, Node::UnitEnumBody(_))
    }

    pub fn as_unit_enum_statement(self) -> Option<&'a UnitEnumStatement> {
        match self {
            Node::UnitEnumStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_unit_enum_statement(&self) -> bool {
        matches!(self, Node::UnitEnumStatement(_))
    }

    pub fn as_backed_enum_case(self) -> Option<&'a BackedEnumCase> {
        match self {
            Node::BackedEnumCase(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_backed_enum_case(&self) -> bool {
        matches!(self, Node::BackedEnumCase(_))
    }

    pub fn as_backed_enum_member(self) -> Option<&'a BackedEnumMember> {
        match self {
            Node::BackedEnumMember(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_backed_enum_member(&self) -> bool {
        matches!(self, Node::BackedEnumMember(_))
    }

    pub fn as_backed_enum_body(self) -> Option<&'a BackedEnumBody> {
        match self {
            Node::BackedEnumBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_backed_enum_body(&self) -> bool {
        matches!(self, Node::BackedEnumBody(_))
    }

    pub fn as_backed_enum_statement(self) -> Option<&'a BackedEnumStatement> {
        match self {
            Node::BackedEnumStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_backed_enum_statement(&self) -> bool {
        matches!(self, Node::BackedEnumStatement(_))
    }

    pub fn as_return_type(self) -> Option<&'a ReturnType> {
        match self {
            Node::ReturnType(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_return_type(&self) -> bool {
        matches!(self, Node::ReturnType(_))
    }

    pub fn as_function_parameter(self) -> Option<&'a FunctionParameter> {
        match self {
            Node::FunctionParameter(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_function_parameter(&self) -> bool {
        matches!(self, Node::FunctionParameter(_))
    }

    pub fn as_function_parameter_list(self) -> Option<&'a FunctionParameterList> {
        match self {
            Node::FunctionParameterList(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_function_parameter_list(&self) -> bool {
        matches!(self, Node::FunctionParameterList(_))
    }

    pub fn as_function_body(self) -> Option<&'a FunctionBody> {
        match self {
            Node::FunctionBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_function_body(&self) -> bool {
        matches!(self, Node::FunctionBody(_))
    }

    pub fn as_function_statement(self) -> Option<&'a FunctionStatement> {
        match self {
            Node::FunctionStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_function_statement(&self) -> bool {
        matches!(self, Node::FunctionStatement(_))
    }

    pub fn as_closure_use_variable(self) -> Option<&'a ClosureUseVariable> {
        match self {
            Node::ClosureUseVariable(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_closure_use_variable(&self) -> bool {
        matches!(self, Node::ClosureUseVariable(_))
    }

    pub fn as_closure_use(self) -> Option<&'a ClosureUse> {
        match self {
            Node::ClosureUse(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_closure_use(&self) -> bool {
        matches!(self, Node::ClosureUse(_))
    }

    pub fn as_closure_expression(self) -> Option<&'a ClosureExpression> {
        match self {
            Node::ClosureExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_closure_expression(&self) -> bool {
        matches!(self, Node::ClosureExpression(_))
    }

    pub fn as_arrow_function_expression(self) -> Option<&'a ArrowFunctionExpression> {
        match self {
            Node::ArrowFunctionExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_arrow_function_expression(&self) -> bool {
        matches!(self, Node::ArrowFunctionExpression(_))
    }

    pub fn as_constructor_parameter(self) -> Option<&'a ConstructorParameter> {
        match self {
            Node::ConstructorParameter(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_constructor_parameter(&self) -> bool {
        matches!(self, Node::ConstructorParameter(_))
    }

    pub fn as_constructor_parameter_list(self) -> Option<&'a ConstructorParameterList> {
        match self {
            Node::ConstructorParameterList(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_constructor_parameter_list(&self) -> bool {
        matches!(self, Node::ConstructorParameterList(_))
    }

    pub fn as_abstract_constructor(self) -> Option<&'a AbstractConstructor> {
        match self {
            Node::AbstractConstructor(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_abstract_constructor(&self) -> bool {
        matches!(self, Node::AbstractConstructor(_))
    }

    pub fn as_concrete_constructor(self) -> Option<&'a ConcreteConstructor> {
        match self {
            Node::ConcreteConstructor(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_concrete_constructor(&self) -> bool {
        matches!(self, Node::ConcreteConstructor(_))
    }

    pub fn as_abstract_method(self) -> Option<&'a AbstractMethod> {
        match self {
            Node::AbstractMethod(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_abstract_method(&self) -> bool {
        matches!(self, Node::AbstractMethod(_))
    }

    pub fn as_concrete_method(self) -> Option<&'a ConcreteMethod> {
        match self {
            Node::ConcreteMethod(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_concrete_method(&self) -> bool {
        matches!(self, Node::ConcreteMethod(_))
    }

    pub fn as_method_body(self) -> Option<&'a MethodBody> {
        match self {
            Node::MethodBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_method_body(&self) -> bool {
        matches!(self, Node::MethodBody(_))
    }

    pub fn as_label_statement(self) -> Option<&'a LabelStatement> {
        match self {
            Node::LabelStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_label_statement(&self) -> bool {
        matches!(self, Node::LabelStatement(_))
    }

    pub fn as_goto_statement(self) -> Option<&'a GotoStatement> {
        match self {
            Node::GotoStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_goto_statement(&self) -> bool {
        matches!(self, Node::GotoStatement(_))
    }

    pub fn as_identifier(self) -> Option<&'a Identifier> {
        match self {
            Node::Identifier(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_identifier(&self) -> bool {
        matches!(self, Node::Identifier(_))
    }

    pub fn as_simple_identifier(self) -> Option<&'a SimpleIdentifier> {
        match self {
            Node::SimpleIdentifier(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_simple_identifier(&self) -> bool {
        matches!(self, Node::SimpleIdentifier(_))
    }

    pub fn as_dynamic_identifier(self) -> Option<&'a DynamicIdentifier> {
        match self {
            Node::DynamicIdentifier(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_dynamic_identifier(&self) -> bool {
        matches!(self, Node::DynamicIdentifier(_))
    }

    pub fn as_interface_extends(self) -> Option<&'a InterfaceExtends> {
        match self {
            Node::InterfaceExtends(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_interface_extends(&self) -> bool {
        matches!(self, Node::InterfaceExtends(_))
    }

    pub fn as_interface_body(self) -> Option<&'a InterfaceBody> {
        match self {
            Node::InterfaceBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_interface_body(&self) -> bool {
        matches!(self, Node::InterfaceBody(_))
    }

    pub fn as_interface_statement(self) -> Option<&'a InterfaceStatement> {
        match self {
            Node::InterfaceStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_interface_statement(&self) -> bool {
        matches!(self, Node::InterfaceStatement(_))
    }

    pub fn as_literal(self) -> Option<&'a Literal> {
        match self {
            Node::Literal(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_literal(&self) -> bool {
        matches!(self, Node::Literal(_))
    }

    pub fn as_literal_kind(self) -> Option<&'a LiteralKind> {
        match self {
            Node::LiteralKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_literal_kind(&self) -> bool {
        matches!(self, Node::LiteralKind(_))
    }

    pub fn as_foreach_statement(self) -> Option<&'a ForeachStatement> {
        match self {
            Node::ForeachStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_foreach_statement(&self) -> bool {
        matches!(self, Node::ForeachStatement(_))
    }

    pub fn as_foreach_statement_iterator(self) -> Option<&'a ForeachStatementIterator> {
        match self {
            Node::ForeachStatementIterator(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_foreach_statement_iterator(&self) -> bool {
        matches!(self, Node::ForeachStatementIterator(_))
    }

    pub fn as_foreach_statement_body(self) -> Option<&'a ForeachStatementBody> {
        match self {
            Node::ForeachStatementBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_foreach_statement_body(&self) -> bool {
        matches!(self, Node::ForeachStatementBody(_))
    }

    pub fn as_for_statement(self) -> Option<&'a ForStatement> {
        match self {
            Node::ForStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_for_statement(&self) -> bool {
        matches!(self, Node::ForStatement(_))
    }

    pub fn as_for_statement_iterator(self) -> Option<&'a ForStatementIterator> {
        match self {
            Node::ForStatementIterator(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_for_statement_iterator(&self) -> bool {
        matches!(self, Node::ForStatementIterator(_))
    }

    pub fn as_for_statement_body(self) -> Option<&'a ForStatementBody> {
        match self {
            Node::ForStatementBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_for_statement_body(&self) -> bool {
        matches!(self, Node::ForStatementBody(_))
    }

    pub fn as_do_while_statement(self) -> Option<&'a DoWhileStatement> {
        match self {
            Node::DoWhileStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_do_while_statement(&self) -> bool {
        matches!(self, Node::DoWhileStatement(_))
    }

    pub fn as_while_statement(self) -> Option<&'a WhileStatement> {
        match self {
            Node::WhileStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_while_statement(&self) -> bool {
        matches!(self, Node::WhileStatement(_))
    }

    pub fn as_while_statement_body(self) -> Option<&'a WhileStatementBody> {
        match self {
            Node::WhileStatementBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_while_statement_body(&self) -> bool {
        matches!(self, Node::WhileStatementBody(_))
    }

    pub fn as_level(self) -> Option<&'a Level> {
        match self {
            Node::Level(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_level(&self) -> bool {
        matches!(self, Node::Level(_))
    }

    pub fn as_break_statement(self) -> Option<&'a BreakStatement> {
        match self {
            Node::BreakStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_break_statement(&self) -> bool {
        matches!(self, Node::BreakStatement(_))
    }

    pub fn as_continue_statement(self) -> Option<&'a ContinueStatement> {
        match self {
            Node::ContinueStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_continue_statement(&self) -> bool {
        matches!(self, Node::ContinueStatement(_))
    }

    pub fn as_visibility_modifier(self) -> Option<&'a VisibilityModifier> {
        match self {
            Node::VisibilityModifier(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_visibility_modifier(&self) -> bool {
        matches!(self, Node::VisibilityModifier(_))
    }

    pub fn as_promoted_property_modifier(self) -> Option<&'a PromotedPropertyModifier> {
        match self {
            Node::PromotedPropertyModifier(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_promoted_property_modifier(&self) -> bool {
        matches!(self, Node::PromotedPropertyModifier(_))
    }

    pub fn as_promoted_property_modifier_group(self) -> Option<&'a PromotedPropertyModifierGroup> {
        match self {
            Node::PromotedPropertyModifierGroup(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_promoted_property_modifier_group(&self) -> bool {
        matches!(self, Node::PromotedPropertyModifierGroup(_))
    }

    pub fn as_property_modifier(self) -> Option<&'a PropertyModifier> {
        match self {
            Node::PropertyModifier(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_property_modifier(&self) -> bool {
        matches!(self, Node::PropertyModifier(_))
    }

    pub fn as_property_modifier_group(self) -> Option<&'a PropertyModifierGroup> {
        match self {
            Node::PropertyModifierGroup(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_property_modifier_group(&self) -> bool {
        matches!(self, Node::PropertyModifierGroup(_))
    }

    pub fn as_method_modifier(self) -> Option<&'a MethodModifier> {
        match self {
            Node::MethodModifier(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_method_modifier(&self) -> bool {
        matches!(self, Node::MethodModifier(_))
    }

    pub fn as_method_modifier_group(self) -> Option<&'a MethodModifierGroup> {
        match self {
            Node::MethodModifierGroup(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_method_modifier_group(&self) -> bool {
        matches!(self, Node::MethodModifierGroup(_))
    }

    pub fn as_class_modifier(self) -> Option<&'a ClassModifier> {
        match self {
            Node::ClassModifier(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_class_modifier(&self) -> bool {
        matches!(self, Node::ClassModifier(_))
    }

    pub fn as_class_modifier_group(self) -> Option<&'a ClassModifierGroup> {
        match self {
            Node::ClassModifierGroup(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_class_modifier_group(&self) -> bool {
        matches!(self, Node::ClassModifierGroup(_))
    }

    pub fn as_constant_modifier(self) -> Option<&'a ConstantModifier> {
        match self {
            Node::ConstantModifier(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_constant_modifier(&self) -> bool {
        matches!(self, Node::ConstantModifier(_))
    }

    pub fn as_constant_modifier_group(self) -> Option<&'a ConstantModifierGroup> {
        match self {
            Node::ConstantModifierGroup(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_constant_modifier_group(&self) -> bool {
        matches!(self, Node::ConstantModifierGroup(_))
    }

    pub fn as_unbraced_namespace(self) -> Option<&'a UnbracedNamespace> {
        match self {
            Node::UnbracedNamespace(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_unbraced_namespace(&self) -> bool {
        matches!(self, Node::UnbracedNamespace(_))
    }

    pub fn as_braced_namespace(self) -> Option<&'a BracedNamespace> {
        match self {
            Node::BracedNamespace(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_braced_namespace(&self) -> bool {
        matches!(self, Node::BracedNamespace(_))
    }

    pub fn as_braced_namespace_body(self) -> Option<&'a BracedNamespaceBody> {
        match self {
            Node::BracedNamespaceBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_braced_namespace_body(&self) -> bool {
        matches!(self, Node::BracedNamespaceBody(_))
    }

    pub fn as_namespace_statement(self) -> Option<&'a NamespaceStatement> {
        match self {
            Node::NamespaceStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_namespace_statement(&self) -> bool {
        matches!(self, Node::NamespaceStatement(_))
    }

    pub fn as_arithmetic_operation_expression(self) -> Option<&'a ArithmeticOperationExpression> {
        match self {
            Node::ArithmeticOperationExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_arithmetic_operation_expression(&self) -> bool {
        matches!(self, Node::ArithmeticOperationExpression(_))
    }

    pub fn as_arithmetic_operation_kind(self) -> Option<&'a ArithmeticOperationKind> {
        match self {
            Node::ArithmeticOperationKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_arithmetic_operation_kind(&self) -> bool {
        matches!(self, Node::ArithmeticOperationKind(_))
    }

    pub fn as_assignment_operation_expression(self) -> Option<&'a AssignmentOperationExpression> {
        match self {
            Node::AssignmentOperationExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_assignment_operation_expression(&self) -> bool {
        matches!(self, Node::AssignmentOperationExpression(_))
    }

    pub fn as_assignment_operation_kind(self) -> Option<&'a AssignmentOperationKind> {
        match self {
            Node::AssignmentOperationKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_assignment_operation_kind(&self) -> bool {
        matches!(self, Node::AssignmentOperationKind(_))
    }

    pub fn as_bitwise_operation_expression(self) -> Option<&'a BitwiseOperationExpression> {
        match self {
            Node::BitwiseOperationExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_bitwise_operation_expression(&self) -> bool {
        matches!(self, Node::BitwiseOperationExpression(_))
    }

    pub fn as_bitwise_operation_kind(self) -> Option<&'a BitwiseOperationKind> {
        match self {
            Node::BitwiseOperationKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_bitwise_operation_kind(&self) -> bool {
        matches!(self, Node::BitwiseOperationKind(_))
    }

    pub fn as_comparison_operation_expression(self) -> Option<&'a ComparisonOperationExpression> {
        match self {
            Node::ComparisonOperationExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_comparison_operation_expression(&self) -> bool {
        matches!(self, Node::ComparisonOperationExpression(_))
    }

    pub fn as_comparison_operation_kind(self) -> Option<&'a ComparisonOperationKind> {
        match self {
            Node::ComparisonOperationKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_comparison_operation_kind(&self) -> bool {
        matches!(self, Node::ComparisonOperationKind(_))
    }

    pub fn as_logical_operation_expression(self) -> Option<&'a LogicalOperationExpression> {
        match self {
            Node::LogicalOperationExpression(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_logical_operation_expression(&self) -> bool {
        matches!(self, Node::LogicalOperationExpression(_))
    }

    pub fn as_logical_operation_kind(self) -> Option<&'a LogicalOperationKind> {
        match self {
            Node::LogicalOperationKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_logical_operation_kind(&self) -> bool {
        matches!(self, Node::LogicalOperationKind(_))
    }

    pub fn as_name(self) -> Option<&'a Name> {
        match self {
            Node::Name(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_name(&self) -> bool {
        matches!(self, Node::Name(_))
    }

    pub fn as_name_kind(self) -> Option<&'a NameKind> {
        match self {
            Node::NameKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_name_kind(&self) -> bool {
        matches!(self, Node::NameKind(_))
    }

    pub fn as_special_name(self) -> Option<&'a SpecialName> {
        match self {
            Node::SpecialName(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_special_name(&self) -> bool {
        matches!(self, Node::SpecialName(_))
    }

    pub fn as_special_name_kind(self) -> Option<&'a SpecialNameKind> {
        match self {
            Node::SpecialNameKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_special_name_kind(&self) -> bool {
        matches!(self, Node::SpecialNameKind(_))
    }

    pub fn as_unresolved_name(self) -> Option<&'a UnresolvedName> {
        match self {
            Node::UnresolvedName(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_unresolved_name(&self) -> bool {
        matches!(self, Node::UnresolvedName(_))
    }

    pub fn as_resolved_name(self) -> Option<&'a ResolvedName> {
        match self {
            Node::ResolvedName(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_resolved_name(&self) -> bool {
        matches!(self, Node::ResolvedName(_))
    }

    pub fn as_property(self) -> Option<&'a Property> {
        match self {
            Node::Property(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_property(&self) -> bool {
        matches!(self, Node::Property(_))
    }

    pub fn as_variable_property(self) -> Option<&'a VariableProperty> {
        match self {
            Node::VariableProperty(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_variable_property(&self) -> bool {
        matches!(self, Node::VariableProperty(_))
    }

    pub fn as_property_entry(self) -> Option<&'a PropertyEntry> {
        match self {
            Node::PropertyEntry(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_property_entry(&self) -> bool {
        matches!(self, Node::PropertyEntry(_))
    }

    pub fn as_property_entry_kind(self) -> Option<&'a PropertyEntryKind> {
        match self {
            Node::PropertyEntryKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_property_entry_kind(&self) -> bool {
        matches!(self, Node::PropertyEntryKind(_))
    }

    pub fn as_trait_body(self) -> Option<&'a TraitBody> {
        match self {
            Node::TraitBody(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_trait_body(&self) -> bool {
        matches!(self, Node::TraitBody(_))
    }

    pub fn as_trait_statement(self) -> Option<&'a TraitStatement> {
        match self {
            Node::TraitStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_trait_statement(&self) -> bool {
        matches!(self, Node::TraitStatement(_))
    }

    pub fn as_trait_usage(self) -> Option<&'a TraitUsage> {
        match self {
            Node::TraitUsage(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_trait_usage(&self) -> bool {
        matches!(self, Node::TraitUsage(_))
    }

    pub fn as_trait_usage_adaptation(self) -> Option<&'a TraitUsageAdaptation> {
        match self {
            Node::TraitUsageAdaptation(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_trait_usage_adaptation(&self) -> bool {
        matches!(self, Node::TraitUsageAdaptation(_))
    }

    pub fn as_trait_usage_adaptation_kind(self) -> Option<&'a TraitUsageAdaptationKind> {
        match self {
            Node::TraitUsageAdaptationKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_trait_usage_adaptation_kind(&self) -> bool {
        matches!(self, Node::TraitUsageAdaptationKind(_))
    }

    pub fn as_catch_type(self) -> Option<&'a CatchType> {
        match self {
            Node::CatchType(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_catch_type(&self) -> bool {
        matches!(self, Node::CatchType(_))
    }

    pub fn as_catch_type_kind(self) -> Option<&'a CatchTypeKind> {
        match self {
            Node::CatchTypeKind(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_catch_type_kind(&self) -> bool {
        matches!(self, Node::CatchTypeKind(_))
    }

    pub fn as_try_statement(self) -> Option<&'a TryStatement> {
        match self {
            Node::TryStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_try_statement(&self) -> bool {
        matches!(self, Node::TryStatement(_))
    }

    pub fn as_catch_block(self) -> Option<&'a CatchBlock> {
        match self {
            Node::CatchBlock(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_catch_block(&self) -> bool {
        matches!(self, Node::CatchBlock(_))
    }

    pub fn as_finally_block(self) -> Option<&'a FinallyBlock> {
        match self {
            Node::FinallyBlock(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_finally_block(&self) -> bool {
        matches!(self, Node::FinallyBlock(_))
    }

    pub fn as_variable(self) -> Option<&'a Variable> {
        match self {
            Node::Variable(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_variable(&self) -> bool {
        matches!(self, Node::Variable(_))
    }

    pub fn as_simple_variable(self) -> Option<&'a SimpleVariable> {
        match self {
            Node::SimpleVariable(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_simple_variable(&self) -> bool {
        matches!(self, Node::SimpleVariable(_))
    }

    pub fn as_variable_variable(self) -> Option<&'a VariableVariable> {
        match self {
            Node::VariableVariable(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_variable_variable(&self) -> bool {
        matches!(self, Node::VariableVariable(_))
    }

    pub fn as_braced_variable_variable(self) -> Option<&'a BracedVariableVariable> {
        match self {
            Node::BracedVariableVariable(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_braced_variable_variable(&self) -> bool {
        matches!(self, Node::BracedVariableVariable(_))
    }

    pub fn as_ending(self) -> Option<&'a Ending> {
        match self {
            Node::Ending(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_ending(&self) -> bool {
        matches!(self, Node::Ending(_))
    }

    pub fn as_static_statement(self) -> Option<&'a StaticStatement> {
        match self {
            Node::StaticStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_static_statement(&self) -> bool {
        matches!(self, Node::StaticStatement(_))
    }

    pub fn as_switch_statement(self) -> Option<&'a SwitchStatement> {
        match self {
            Node::SwitchStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_switch_statement(&self) -> bool {
        matches!(self, Node::SwitchStatement(_))
    }

    pub fn as_echo_statement(self) -> Option<&'a EchoStatement> {
        match self {
            Node::EchoStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_echo_statement(&self) -> bool {
        matches!(self, Node::EchoStatement(_))
    }

    pub fn as_return_statement(self) -> Option<&'a ReturnStatement> {
        match self {
            Node::ReturnStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_return_statement(&self) -> bool {
        matches!(self, Node::ReturnStatement(_))
    }

    pub fn as_use_statement(self) -> Option<&'a UseStatement> {
        match self {
            Node::UseStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_use_statement(&self) -> bool {
        matches!(self, Node::UseStatement(_))
    }

    pub fn as_group_use_statement(self) -> Option<&'a GroupUseStatement> {
        match self {
            Node::GroupUseStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_group_use_statement(&self) -> bool {
        matches!(self, Node::GroupUseStatement(_))
    }

    pub fn as_halt_compiler_statement(self) -> Option<&'a HaltCompilerStatement> {
        match self {
            Node::HaltCompilerStatement(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_halt_compiler_statement(&self) -> bool {
        matches!(self, Node::HaltCompilerStatement(_))
    }

    pub fn as_static_var(self) -> Option<&'a StaticVar> {
        match self {
            Node::StaticVar(node) => Some(node),
            _ => None,
        }
    }

    pub fn is_static_var(&self) -> bool {
        matches!(self, Node::StaticVar(_))
    }
}
