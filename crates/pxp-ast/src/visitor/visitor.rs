// This file is automatically generated by the generate-visitor.php script.
// Do not modify this file directly.
#![allow(unused)]

use super::*;
use crate::*;
use pxp_span::Span;
use pxp_syntax::comments::Comment;
use pxp_type::Type;

pub trait Visitor {
    fn before<T: Nodeable + ?Sized>(&mut self, node: &T) {
        // This method is called before visiting a node.
    }

    fn after<T: Nodeable + ?Sized>(&mut self, node: &T) {
        // This method is called after visiting a node.
    }

    fn visit(&mut self, node: &Vec<Statement>) {
        self.before(node);
        walk(self, node);
        self.after(node);
    }

    fn visit_statement(&mut self, node: &Statement) {
        self.before(node);
        walk_statement(self, node);
        self.after(node);
    }

    fn visit_statement_kind(&mut self, node: &StatementKind) {
        self.before(node);
        walk_statement_kind(self, node);
        self.after(node);
    }

    fn visit_expression(&mut self, node: &Expression) {
        self.before(node);
        walk_expression(self, node);
        self.after(node);
    }

    fn visit_expression_kind(&mut self, node: &ExpressionKind) {
        self.before(node);
        walk_expression_kind(self, node);
        self.after(node);
    }

    fn visit_inline_html_statement(&mut self, node: &InlineHtmlStatement) {
        self.before(node);
        self.after(node);
    }

    fn visit_full_opening_tag_statement(&mut self, node: &FullOpeningTagStatement) {
        self.before(node);
        self.after(node);
    }

    fn visit_short_opening_tag_statement(&mut self, node: &ShortOpeningTagStatement) {
        self.before(node);
        self.after(node);
    }

    fn visit_echo_opening_tag_statement(&mut self, node: &EchoOpeningTagStatement) {
        self.before(node);
        self.after(node);
    }

    fn visit_closing_tag_statement(&mut self, node: &ClosingTagStatement) {
        self.before(node);
        self.after(node);
    }

    fn visit_expression_statement(&mut self, node: &ExpressionStatement) {
        self.before(node);
        walk_expression_statement(self, node);
        self.after(node);
    }

    fn visit_global_statement(&mut self, node: &GlobalStatement) {
        self.before(node);
        walk_global_statement(self, node);
        self.after(node);
    }

    fn visit_block_statement(&mut self, node: &BlockStatement) {
        self.before(node);
        walk_block_statement(self, node);
        self.after(node);
    }

    fn visit_cast_kind(&mut self, node: &CastKind) {
        self.before(node);
        self.after(node);
    }

    fn visit_case(&mut self, node: &Case) {
        self.before(node);
        walk_case(self, node);
        self.after(node);
    }

    fn visit_use(&mut self, node: &Use) {
        self.before(node);
        walk_use(self, node);
        self.after(node);
    }

    fn visit_use_kind(&mut self, node: &UseKind) {
        self.before(node);
        walk_use_kind(self, node);
        self.after(node);
    }

    fn visit_eval_expression(&mut self, node: &EvalExpression) {
        self.before(node);
        walk_eval_expression(self, node);
        self.after(node);
    }

    fn visit_empty_expression(&mut self, node: &EmptyExpression) {
        self.before(node);
        walk_empty_expression(self, node);
        self.after(node);
    }

    fn visit_die_expression(&mut self, node: &DieExpression) {
        self.before(node);
        walk_die_expression(self, node);
        self.after(node);
    }

    fn visit_exit_expression(&mut self, node: &ExitExpression) {
        self.before(node);
        walk_exit_expression(self, node);
        self.after(node);
    }

    fn visit_isset_expression(&mut self, node: &IssetExpression) {
        self.before(node);
        walk_isset_expression(self, node);
        self.after(node);
    }

    fn visit_unset_expression(&mut self, node: &UnsetExpression) {
        self.before(node);
        walk_unset_expression(self, node);
        self.after(node);
    }

    fn visit_print_expression(&mut self, node: &PrintExpression) {
        self.before(node);
        walk_print_expression(self, node);
        self.after(node);
    }

    fn visit_concat_expression(&mut self, node: &ConcatExpression) {
        self.before(node);
        walk_concat_expression(self, node);
        self.after(node);
    }

    fn visit_instanceof_expression(&mut self, node: &InstanceofExpression) {
        self.before(node);
        walk_instanceof_expression(self, node);
        self.after(node);
    }

    fn visit_reference_expression(&mut self, node: &ReferenceExpression) {
        self.before(node);
        walk_reference_expression(self, node);
        self.after(node);
    }

    fn visit_parenthesized_expression(&mut self, node: &ParenthesizedExpression) {
        self.before(node);
        walk_parenthesized_expression(self, node);
        self.after(node);
    }

    fn visit_error_suppress_expression(&mut self, node: &ErrorSuppressExpression) {
        self.before(node);
        walk_error_suppress_expression(self, node);
        self.after(node);
    }

    fn visit_include_expression(&mut self, node: &IncludeExpression) {
        self.before(node);
        walk_include_expression(self, node);
        self.after(node);
    }

    fn visit_include_once_expression(&mut self, node: &IncludeOnceExpression) {
        self.before(node);
        walk_include_once_expression(self, node);
        self.after(node);
    }

    fn visit_require_expression(&mut self, node: &RequireExpression) {
        self.before(node);
        walk_require_expression(self, node);
        self.after(node);
    }

    fn visit_require_once_expression(&mut self, node: &RequireOnceExpression) {
        self.before(node);
        walk_require_once_expression(self, node);
        self.after(node);
    }

    fn visit_function_call_expression(&mut self, node: &FunctionCallExpression) {
        self.before(node);
        walk_function_call_expression(self, node);
        self.after(node);
    }

    fn visit_function_closure_creation_expression(
        &mut self,
        node: &FunctionClosureCreationExpression,
    ) {
        self.before(node);
        walk_function_closure_creation_expression(self, node);
        self.after(node);
    }

    fn visit_method_call_expression(&mut self, node: &MethodCallExpression) {
        self.before(node);
        walk_method_call_expression(self, node);
        self.after(node);
    }

    fn visit_method_closure_creation_expression(&mut self, node: &MethodClosureCreationExpression) {
        self.before(node);
        walk_method_closure_creation_expression(self, node);
        self.after(node);
    }

    fn visit_nullsafe_method_call_expression(&mut self, node: &NullsafeMethodCallExpression) {
        self.before(node);
        walk_nullsafe_method_call_expression(self, node);
        self.after(node);
    }

    fn visit_static_method_call_expression(&mut self, node: &StaticMethodCallExpression) {
        self.before(node);
        walk_static_method_call_expression(self, node);
        self.after(node);
    }

    fn visit_static_variable_method_call_expression(
        &mut self,
        node: &StaticVariableMethodCallExpression,
    ) {
        self.before(node);
        walk_static_variable_method_call_expression(self, node);
        self.after(node);
    }

    fn visit_static_method_closure_creation_expression(
        &mut self,
        node: &StaticMethodClosureCreationExpression,
    ) {
        self.before(node);
        walk_static_method_closure_creation_expression(self, node);
        self.after(node);
    }

    fn visit_static_variable_method_closure_creation_expression(
        &mut self,
        node: &StaticVariableMethodClosureCreationExpression,
    ) {
        self.before(node);
        walk_static_variable_method_closure_creation_expression(self, node);
        self.after(node);
    }

    fn visit_property_fetch_expression(&mut self, node: &PropertyFetchExpression) {
        self.before(node);
        walk_property_fetch_expression(self, node);
        self.after(node);
    }

    fn visit_nullsafe_property_fetch_expression(&mut self, node: &NullsafePropertyFetchExpression) {
        self.before(node);
        walk_nullsafe_property_fetch_expression(self, node);
        self.after(node);
    }

    fn visit_static_property_fetch_expression(&mut self, node: &StaticPropertyFetchExpression) {
        self.before(node);
        walk_static_property_fetch_expression(self, node);
        self.after(node);
    }

    fn visit_constant_fetch_expression(&mut self, node: &ConstantFetchExpression) {
        self.before(node);
        walk_constant_fetch_expression(self, node);
        self.after(node);
    }

    fn visit_short_array_expression(&mut self, node: &ShortArrayExpression) {
        self.before(node);
        walk_short_array_expression(self, node);
        self.after(node);
    }

    fn visit_array_expression(&mut self, node: &ArrayExpression) {
        self.before(node);
        walk_array_expression(self, node);
        self.after(node);
    }

    fn visit_list_expression(&mut self, node: &ListExpression) {
        self.before(node);
        walk_list_expression(self, node);
        self.after(node);
    }

    fn visit_new_expression(&mut self, node: &NewExpression) {
        self.before(node);
        walk_new_expression(self, node);
        self.after(node);
    }

    fn visit_interpolated_string_expression(&mut self, node: &InterpolatedStringExpression) {
        self.before(node);
        walk_interpolated_string_expression(self, node);
        self.after(node);
    }

    fn visit_heredoc_expression(&mut self, node: &HeredocExpression) {
        self.before(node);
        walk_heredoc_expression(self, node);
        self.after(node);
    }

    fn visit_nowdoc_expression(&mut self, node: &NowdocExpression) {
        self.before(node);
        self.after(node);
    }

    fn visit_shell_exec_expression(&mut self, node: &ShellExecExpression) {
        self.before(node);
        walk_shell_exec_expression(self, node);
        self.after(node);
    }

    fn visit_bool_expression(&mut self, node: &BoolExpression) {
        self.before(node);
        self.after(node);
    }

    fn visit_array_index_expression(&mut self, node: &ArrayIndexExpression) {
        self.before(node);
        walk_array_index_expression(self, node);
        self.after(node);
    }

    fn visit_short_ternary_expression(&mut self, node: &ShortTernaryExpression) {
        self.before(node);
        walk_short_ternary_expression(self, node);
        self.after(node);
    }

    fn visit_ternary_expression(&mut self, node: &TernaryExpression) {
        self.before(node);
        walk_ternary_expression(self, node);
        self.after(node);
    }

    fn visit_coalesce_expression(&mut self, node: &CoalesceExpression) {
        self.before(node);
        walk_coalesce_expression(self, node);
        self.after(node);
    }

    fn visit_clone_expression(&mut self, node: &CloneExpression) {
        self.before(node);
        walk_clone_expression(self, node);
        self.after(node);
    }

    fn visit_match_expression(&mut self, node: &MatchExpression) {
        self.before(node);
        walk_match_expression(self, node);
        self.after(node);
    }

    fn visit_throw_expression(&mut self, node: &ThrowExpression) {
        self.before(node);
        walk_throw_expression(self, node);
        self.after(node);
    }

    fn visit_yield_expression(&mut self, node: &YieldExpression) {
        self.before(node);
        walk_yield_expression(self, node);
        self.after(node);
    }

    fn visit_yield_from_expression(&mut self, node: &YieldFromExpression) {
        self.before(node);
        walk_yield_from_expression(self, node);
        self.after(node);
    }

    fn visit_cast_expression(&mut self, node: &CastExpression) {
        self.before(node);
        walk_cast_expression(self, node);
        self.after(node);
    }

    fn visit_default_match_arm(&mut self, node: &DefaultMatchArm) {
        self.before(node);
        walk_default_match_arm(self, node);
        self.after(node);
    }

    fn visit_match_arm(&mut self, node: &MatchArm) {
        self.before(node);
        walk_match_arm(self, node);
        self.after(node);
    }

    fn visit_magic_constant_expression(&mut self, node: &MagicConstantExpression) {
        self.before(node);
        self.after(node);
    }

    fn visit_string_part(&mut self, node: &StringPart) {
        self.before(node);
        walk_string_part(self, node);
        self.after(node);
    }

    fn visit_literal_string_part(&mut self, node: &LiteralStringPart) {
        self.before(node);
        self.after(node);
    }

    fn visit_expression_string_part(&mut self, node: &ExpressionStringPart) {
        self.before(node);
        walk_expression_string_part(self, node);
        self.after(node);
    }

    fn visit_array_item(&mut self, node: &ArrayItem) {
        self.before(node);
        walk_array_item(self, node);
        self.after(node);
    }

    fn visit_array_item_value(&mut self, node: &ArrayItemValue) {
        self.before(node);
        walk_array_item_value(self, node);
        self.after(node);
    }

    fn visit_array_item_referenced_value(&mut self, node: &ArrayItemReferencedValue) {
        self.before(node);
        walk_array_item_referenced_value(self, node);
        self.after(node);
    }

    fn visit_array_item_spread_value(&mut self, node: &ArrayItemSpreadValue) {
        self.before(node);
        walk_array_item_spread_value(self, node);
        self.after(node);
    }

    fn visit_array_item_key_value(&mut self, node: &ArrayItemKeyValue) {
        self.before(node);
        walk_array_item_key_value(self, node);
        self.after(node);
    }

    fn visit_array_item_referenced_key_value(&mut self, node: &ArrayItemReferencedKeyValue) {
        self.before(node);
        walk_array_item_referenced_key_value(self, node);
        self.after(node);
    }

    fn visit_list_entry(&mut self, node: &ListEntry) {
        self.before(node);
        walk_list_entry(self, node);
        self.after(node);
    }

    fn visit_list_entry_value(&mut self, node: &ListEntryValue) {
        self.before(node);
        walk_list_entry_value(self, node);
        self.after(node);
    }

    fn visit_list_entry_key_value(&mut self, node: &ListEntryKeyValue) {
        self.before(node);
        walk_list_entry_key_value(self, node);
        self.after(node);
    }

    fn visit_positional_argument(&mut self, node: &PositionalArgument) {
        self.before(node);
        walk_positional_argument(self, node);
        self.after(node);
    }

    fn visit_named_argument(&mut self, node: &NamedArgument) {
        self.before(node);
        walk_named_argument(self, node);
        self.after(node);
    }

    fn visit_argument(&mut self, node: &Argument) {
        self.before(node);
        walk_argument(self, node);
        self.after(node);
    }

    fn visit_argument_list(&mut self, node: &ArgumentList) {
        self.before(node);
        walk_argument_list(self, node);
        self.after(node);
    }

    fn visit_single_argument(&mut self, node: &SingleArgument) {
        self.before(node);
        walk_single_argument(self, node);
        self.after(node);
    }

    fn visit_argument_placeholder(&mut self, node: &ArgumentPlaceholder) {
        self.before(node);
        self.after(node);
    }

    fn visit_attribute(&mut self, node: &Attribute) {
        self.before(node);
        walk_attribute(self, node);
        self.after(node);
    }

    fn visit_attribute_group(&mut self, node: &AttributeGroup) {
        self.before(node);
        walk_attribute_group(self, node);
        self.after(node);
    }

    fn visit_class_body(&mut self, node: &ClassBody) {
        self.before(node);
        walk_class_body(self, node);
        self.after(node);
    }

    fn visit_class_statement(&mut self, node: &ClassStatement) {
        self.before(node);
        walk_class_statement(self, node);
        self.after(node);
    }

    fn visit_anonymous_class_body(&mut self, node: &AnonymousClassBody) {
        self.before(node);
        walk_anonymous_class_body(self, node);
        self.after(node);
    }

    fn visit_anonymous_class_expression(&mut self, node: &AnonymousClassExpression) {
        self.before(node);
        walk_anonymous_class_expression(self, node);
        self.after(node);
    }

    fn visit_class_extends(&mut self, node: &ClassExtends) {
        self.before(node);
        walk_class_extends(self, node);
        self.after(node);
    }

    fn visit_class_implements(&mut self, node: &ClassImplements) {
        self.before(node);
        walk_class_implements(self, node);
        self.after(node);
    }

    fn visit_classish_member(&mut self, node: &ClassishMember) {
        self.before(node);
        walk_classish_member(self, node);
        self.after(node);
    }

    fn visit_constant_entry(&mut self, node: &ConstantEntry) {
        self.before(node);
        walk_constant_entry(self, node);
        self.after(node);
    }

    fn visit_classish_constant_entry(&mut self, node: &ClassishConstantEntry) {
        self.before(node);
        walk_classish_constant_entry(self, node);
        self.after(node);
    }

    fn visit_constant_statement(&mut self, node: &ConstantStatement) {
        self.before(node);
        walk_constant_statement(self, node);
        self.after(node);
    }

    fn visit_classish_constant(&mut self, node: &ClassishConstant) {
        self.before(node);
        walk_classish_constant(self, node);
        self.after(node);
    }

    fn visit_if_statement(&mut self, node: &IfStatement) {
        self.before(node);
        walk_if_statement(self, node);
        self.after(node);
    }

    fn visit_if_statement_body(&mut self, node: &IfStatementBody) {
        self.before(node);
        walk_if_statement_body(self, node);
        self.after(node);
    }

    fn visit_if_statement_else_if(&mut self, node: &IfStatementElseIf) {
        self.before(node);
        walk_if_statement_else_if(self, node);
        self.after(node);
    }

    fn visit_if_statement_else(&mut self, node: &IfStatementElse) {
        self.before(node);
        walk_if_statement_else(self, node);
        self.after(node);
    }

    fn visit_if_statement_else_if_block(&mut self, node: &IfStatementElseIfBlock) {
        self.before(node);
        walk_if_statement_else_if_block(self, node);
        self.after(node);
    }

    fn visit_if_statement_else_block(&mut self, node: &IfStatementElseBlock) {
        self.before(node);
        walk_if_statement_else_block(self, node);
        self.after(node);
    }

    fn visit_data_type(&mut self, node: &DataType) {
        self.before(node);
        walk_data_type(self, node);
        self.after(node);
    }

    fn visit_declare_entry(&mut self, node: &DeclareEntry) {
        self.before(node);
        walk_declare_entry(self, node);
        self.after(node);
    }

    fn visit_declare_entry_group(&mut self, node: &DeclareEntryGroup) {
        self.before(node);
        walk_declare_entry_group(self, node);
        self.after(node);
    }

    fn visit_declare_body(&mut self, node: &DeclareBody) {
        self.before(node);
        walk_declare_body(self, node);
        self.after(node);
    }

    fn visit_declare_statement(&mut self, node: &DeclareStatement) {
        self.before(node);
        walk_declare_statement(self, node);
        self.after(node);
    }

    fn visit_unit_enum_case(&mut self, node: &UnitEnumCase) {
        self.before(node);
        walk_unit_enum_case(self, node);
        self.after(node);
    }

    fn visit_unit_enum_member(&mut self, node: &UnitEnumMember) {
        self.before(node);
        walk_unit_enum_member(self, node);
        self.after(node);
    }

    fn visit_unit_enum_body(&mut self, node: &UnitEnumBody) {
        self.before(node);
        walk_unit_enum_body(self, node);
        self.after(node);
    }

    fn visit_unit_enum_statement(&mut self, node: &UnitEnumStatement) {
        self.before(node);
        walk_unit_enum_statement(self, node);
        self.after(node);
    }

    fn visit_backed_enum_case(&mut self, node: &BackedEnumCase) {
        self.before(node);
        walk_backed_enum_case(self, node);
        self.after(node);
    }

    fn visit_backed_enum_member(&mut self, node: &BackedEnumMember) {
        self.before(node);
        walk_backed_enum_member(self, node);
        self.after(node);
    }

    fn visit_backed_enum_body(&mut self, node: &BackedEnumBody) {
        self.before(node);
        walk_backed_enum_body(self, node);
        self.after(node);
    }

    fn visit_backed_enum_statement(&mut self, node: &BackedEnumStatement) {
        self.before(node);
        walk_backed_enum_statement(self, node);
        self.after(node);
    }

    fn visit_return_type(&mut self, node: &ReturnType) {
        self.before(node);
        walk_return_type(self, node);
        self.after(node);
    }

    fn visit_function_parameter(&mut self, node: &FunctionParameter) {
        self.before(node);
        walk_function_parameter(self, node);
        self.after(node);
    }

    fn visit_function_parameter_list(&mut self, node: &FunctionParameterList) {
        self.before(node);
        walk_function_parameter_list(self, node);
        self.after(node);
    }

    fn visit_function_body(&mut self, node: &FunctionBody) {
        self.before(node);
        walk_function_body(self, node);
        self.after(node);
    }

    fn visit_function_statement(&mut self, node: &FunctionStatement) {
        self.before(node);
        walk_function_statement(self, node);
        self.after(node);
    }

    fn visit_closure_use_variable(&mut self, node: &ClosureUseVariable) {
        self.before(node);
        walk_closure_use_variable(self, node);
        self.after(node);
    }

    fn visit_closure_use(&mut self, node: &ClosureUse) {
        self.before(node);
        walk_closure_use(self, node);
        self.after(node);
    }

    fn visit_closure_expression(&mut self, node: &ClosureExpression) {
        self.before(node);
        walk_closure_expression(self, node);
        self.after(node);
    }

    fn visit_arrow_function_expression(&mut self, node: &ArrowFunctionExpression) {
        self.before(node);
        walk_arrow_function_expression(self, node);
        self.after(node);
    }

    fn visit_constructor_parameter(&mut self, node: &ConstructorParameter) {
        self.before(node);
        walk_constructor_parameter(self, node);
        self.after(node);
    }

    fn visit_constructor_parameter_list(&mut self, node: &ConstructorParameterList) {
        self.before(node);
        walk_constructor_parameter_list(self, node);
        self.after(node);
    }

    fn visit_abstract_constructor(&mut self, node: &AbstractConstructor) {
        self.before(node);
        walk_abstract_constructor(self, node);
        self.after(node);
    }

    fn visit_concrete_constructor(&mut self, node: &ConcreteConstructor) {
        self.before(node);
        walk_concrete_constructor(self, node);
        self.after(node);
    }

    fn visit_abstract_method(&mut self, node: &AbstractMethod) {
        self.before(node);
        walk_abstract_method(self, node);
        self.after(node);
    }

    fn visit_concrete_method(&mut self, node: &ConcreteMethod) {
        self.before(node);
        walk_concrete_method(self, node);
        self.after(node);
    }

    fn visit_method_body(&mut self, node: &MethodBody) {
        self.before(node);
        walk_method_body(self, node);
        self.after(node);
    }

    fn visit_label_statement(&mut self, node: &LabelStatement) {
        self.before(node);
        walk_label_statement(self, node);
        self.after(node);
    }

    fn visit_goto_statement(&mut self, node: &GotoStatement) {
        self.before(node);
        walk_goto_statement(self, node);
        self.after(node);
    }

    fn visit_identifier(&mut self, node: &Identifier) {
        self.before(node);
        walk_identifier(self, node);
        self.after(node);
    }

    fn visit_simple_identifier(&mut self, node: &SimpleIdentifier) {
        self.before(node);
        self.after(node);
    }

    fn visit_dynamic_identifier(&mut self, node: &DynamicIdentifier) {
        self.before(node);
        walk_dynamic_identifier(self, node);
        self.after(node);
    }

    fn visit_interface_extends(&mut self, node: &InterfaceExtends) {
        self.before(node);
        walk_interface_extends(self, node);
        self.after(node);
    }

    fn visit_interface_body(&mut self, node: &InterfaceBody) {
        self.before(node);
        walk_interface_body(self, node);
        self.after(node);
    }

    fn visit_interface_statement(&mut self, node: &InterfaceStatement) {
        self.before(node);
        walk_interface_statement(self, node);
        self.after(node);
    }

    fn visit_literal(&mut self, node: &Literal) {
        self.before(node);
        walk_literal(self, node);
        self.after(node);
    }

    fn visit_literal_kind(&mut self, node: &LiteralKind) {
        self.before(node);
        walk_literal_kind(self, node);
        self.after(node);
    }

    fn visit_foreach_statement(&mut self, node: &ForeachStatement) {
        self.before(node);
        walk_foreach_statement(self, node);
        self.after(node);
    }

    fn visit_foreach_statement_iterator(&mut self, node: &ForeachStatementIterator) {
        self.before(node);
        walk_foreach_statement_iterator(self, node);
        self.after(node);
    }

    fn visit_foreach_statement_body(&mut self, node: &ForeachStatementBody) {
        self.before(node);
        walk_foreach_statement_body(self, node);
        self.after(node);
    }

    fn visit_for_statement(&mut self, node: &ForStatement) {
        self.before(node);
        walk_for_statement(self, node);
        self.after(node);
    }

    fn visit_for_statement_iterator(&mut self, node: &ForStatementIterator) {
        self.before(node);
        walk_for_statement_iterator(self, node);
        self.after(node);
    }

    fn visit_for_statement_body(&mut self, node: &ForStatementBody) {
        self.before(node);
        walk_for_statement_body(self, node);
        self.after(node);
    }

    fn visit_do_while_statement(&mut self, node: &DoWhileStatement) {
        self.before(node);
        walk_do_while_statement(self, node);
        self.after(node);
    }

    fn visit_while_statement(&mut self, node: &WhileStatement) {
        self.before(node);
        walk_while_statement(self, node);
        self.after(node);
    }

    fn visit_while_statement_body(&mut self, node: &WhileStatementBody) {
        self.before(node);
        walk_while_statement_body(self, node);
        self.after(node);
    }

    fn visit_level(&mut self, node: &Level) {
        self.before(node);
        walk_level(self, node);
        self.after(node);
    }

    fn visit_break_statement(&mut self, node: &BreakStatement) {
        self.before(node);
        walk_break_statement(self, node);
        self.after(node);
    }

    fn visit_continue_statement(&mut self, node: &ContinueStatement) {
        self.before(node);
        walk_continue_statement(self, node);
        self.after(node);
    }

    fn visit_visibility_modifier(&mut self, node: &VisibilityModifier) {
        self.before(node);
        self.after(node);
    }

    fn visit_promoted_property_modifier(&mut self, node: &PromotedPropertyModifier) {
        self.before(node);
        self.after(node);
    }

    fn visit_promoted_property_modifier_group(&mut self, node: &PromotedPropertyModifierGroup) {
        self.before(node);
        walk_promoted_property_modifier_group(self, node);
        self.after(node);
    }

    fn visit_property_modifier(&mut self, node: &PropertyModifier) {
        self.before(node);
        self.after(node);
    }

    fn visit_property_modifier_group(&mut self, node: &PropertyModifierGroup) {
        self.before(node);
        walk_property_modifier_group(self, node);
        self.after(node);
    }

    fn visit_method_modifier(&mut self, node: &MethodModifier) {
        self.before(node);
        self.after(node);
    }

    fn visit_method_modifier_group(&mut self, node: &MethodModifierGroup) {
        self.before(node);
        walk_method_modifier_group(self, node);
        self.after(node);
    }

    fn visit_class_modifier(&mut self, node: &ClassModifier) {
        self.before(node);
        self.after(node);
    }

    fn visit_class_modifier_group(&mut self, node: &ClassModifierGroup) {
        self.before(node);
        walk_class_modifier_group(self, node);
        self.after(node);
    }

    fn visit_constant_modifier(&mut self, node: &ConstantModifier) {
        self.before(node);
        self.after(node);
    }

    fn visit_constant_modifier_group(&mut self, node: &ConstantModifierGroup) {
        self.before(node);
        walk_constant_modifier_group(self, node);
        self.after(node);
    }

    fn visit_unbraced_namespace(&mut self, node: &UnbracedNamespace) {
        self.before(node);
        walk_unbraced_namespace(self, node);
        self.after(node);
    }

    fn visit_braced_namespace(&mut self, node: &BracedNamespace) {
        self.before(node);
        walk_braced_namespace(self, node);
        self.after(node);
    }

    fn visit_braced_namespace_body(&mut self, node: &BracedNamespaceBody) {
        self.before(node);
        walk_braced_namespace_body(self, node);
        self.after(node);
    }

    fn visit_namespace_statement(&mut self, node: &NamespaceStatement) {
        self.before(node);
        walk_namespace_statement(self, node);
        self.after(node);
    }

    fn visit_arithmetic_operation_expression(&mut self, node: &ArithmeticOperationExpression) {
        self.before(node);
        walk_arithmetic_operation_expression(self, node);
        self.after(node);
    }

    fn visit_arithmetic_operation_kind(&mut self, node: &ArithmeticOperationKind) {
        self.before(node);
        walk_arithmetic_operation_kind(self, node);
        self.after(node);
    }

    fn visit_assignment_operation_expression(&mut self, node: &AssignmentOperationExpression) {
        self.before(node);
        walk_assignment_operation_expression(self, node);
        self.after(node);
    }

    fn visit_assignment_operation_kind(&mut self, node: &AssignmentOperationKind) {
        self.before(node);
        walk_assignment_operation_kind(self, node);
        self.after(node);
    }

    fn visit_bitwise_operation_expression(&mut self, node: &BitwiseOperationExpression) {
        self.before(node);
        walk_bitwise_operation_expression(self, node);
        self.after(node);
    }

    fn visit_bitwise_operation_kind(&mut self, node: &BitwiseOperationKind) {
        self.before(node);
        walk_bitwise_operation_kind(self, node);
        self.after(node);
    }

    fn visit_comparison_operation_expression(&mut self, node: &ComparisonOperationExpression) {
        self.before(node);
        walk_comparison_operation_expression(self, node);
        self.after(node);
    }

    fn visit_comparison_operation_kind(&mut self, node: &ComparisonOperationKind) {
        self.before(node);
        walk_comparison_operation_kind(self, node);
        self.after(node);
    }

    fn visit_logical_operation_expression(&mut self, node: &LogicalOperationExpression) {
        self.before(node);
        walk_logical_operation_expression(self, node);
        self.after(node);
    }

    fn visit_logical_operation_kind(&mut self, node: &LogicalOperationKind) {
        self.before(node);
        walk_logical_operation_kind(self, node);
        self.after(node);
    }

    fn visit_name(&mut self, node: &Name) {
        self.before(node);
        walk_name(self, node);
        self.after(node);
    }

    fn visit_name_kind(&mut self, node: &NameKind) {
        self.before(node);
        walk_name_kind(self, node);
        self.after(node);
    }

    fn visit_special_name(&mut self, node: &SpecialName) {
        self.before(node);
        walk_special_name(self, node);
        self.after(node);
    }

    fn visit_special_name_kind(&mut self, node: &SpecialNameKind) {
        self.before(node);
        self.after(node);
    }

    fn visit_unresolved_name(&mut self, node: &UnresolvedName) {
        self.before(node);
        self.after(node);
    }

    fn visit_resolved_name(&mut self, node: &ResolvedName) {
        self.before(node);
        self.after(node);
    }

    fn visit_property(&mut self, node: &Property) {
        self.before(node);
        walk_property(self, node);
        self.after(node);
    }

    fn visit_variable_property(&mut self, node: &VariableProperty) {
        self.before(node);
        walk_variable_property(self, node);
        self.after(node);
    }

    fn visit_property_entry(&mut self, node: &PropertyEntry) {
        self.before(node);
        walk_property_entry(self, node);
        self.after(node);
    }

    fn visit_property_entry_kind(&mut self, node: &PropertyEntryKind) {
        self.before(node);
        walk_property_entry_kind(self, node);
        self.after(node);
    }

    fn visit_trait_body(&mut self, node: &TraitBody) {
        self.before(node);
        walk_trait_body(self, node);
        self.after(node);
    }

    fn visit_trait_statement(&mut self, node: &TraitStatement) {
        self.before(node);
        walk_trait_statement(self, node);
        self.after(node);
    }

    fn visit_trait_usage(&mut self, node: &TraitUsage) {
        self.before(node);
        walk_trait_usage(self, node);
        self.after(node);
    }

    fn visit_trait_usage_adaptation(&mut self, node: &TraitUsageAdaptation) {
        self.before(node);
        walk_trait_usage_adaptation(self, node);
        self.after(node);
    }

    fn visit_trait_usage_adaptation_kind(&mut self, node: &TraitUsageAdaptationKind) {
        self.before(node);
        walk_trait_usage_adaptation_kind(self, node);
        self.after(node);
    }

    fn visit_catch_type(&mut self, node: &CatchType) {
        self.before(node);
        walk_catch_type(self, node);
        self.after(node);
    }

    fn visit_catch_type_kind(&mut self, node: &CatchTypeKind) {
        self.before(node);
        walk_catch_type_kind(self, node);
        self.after(node);
    }

    fn visit_try_statement(&mut self, node: &TryStatement) {
        self.before(node);
        walk_try_statement(self, node);
        self.after(node);
    }

    fn visit_catch_block(&mut self, node: &CatchBlock) {
        self.before(node);
        walk_catch_block(self, node);
        self.after(node);
    }

    fn visit_finally_block(&mut self, node: &FinallyBlock) {
        self.before(node);
        walk_finally_block(self, node);
        self.after(node);
    }

    fn visit_variable(&mut self, node: &Variable) {
        self.before(node);
        walk_variable(self, node);
        self.after(node);
    }

    fn visit_simple_variable(&mut self, node: &SimpleVariable) {
        self.before(node);
        self.after(node);
    }

    fn visit_variable_variable(&mut self, node: &VariableVariable) {
        self.before(node);
        walk_variable_variable(self, node);
        self.after(node);
    }

    fn visit_braced_variable_variable(&mut self, node: &BracedVariableVariable) {
        self.before(node);
        walk_braced_variable_variable(self, node);
        self.after(node);
    }

    fn visit_ending(&mut self, node: &Ending) {
        self.before(node);
        self.after(node);
    }

    fn visit_static_statement(&mut self, node: &StaticStatement) {
        self.before(node);
        walk_static_statement(self, node);
        self.after(node);
    }

    fn visit_switch_statement(&mut self, node: &SwitchStatement) {
        self.before(node);
        walk_switch_statement(self, node);
        self.after(node);
    }

    fn visit_echo_statement(&mut self, node: &EchoStatement) {
        self.before(node);
        walk_echo_statement(self, node);
        self.after(node);
    }

    fn visit_return_statement(&mut self, node: &ReturnStatement) {
        self.before(node);
        walk_return_statement(self, node);
        self.after(node);
    }

    fn visit_use_statement(&mut self, node: &UseStatement) {
        self.before(node);
        walk_use_statement(self, node);
        self.after(node);
    }

    fn visit_group_use_statement(&mut self, node: &GroupUseStatement) {
        self.before(node);
        walk_group_use_statement(self, node);
        self.after(node);
    }

    fn visit_halt_compiler_statement(&mut self, node: &HaltCompilerStatement) {
        self.before(node);
        self.after(node);
    }

    fn visit_static_var(&mut self, node: &StaticVar) {
        self.before(node);
        walk_static_var(self, node);
        self.after(node);
    }
}
